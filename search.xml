<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java学习（5）常用API接口]]></title>
    <url>%2F2019%2F02%2F15%2Fjava%E5%AD%A6%E4%B9%A0%EF%BC%885%EF%BC%89api%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[常用API接口1、使用函数库（Java API）要使用API中的类，你必须知道它被放在哪个包中。 必须指明程序代码中使用的类的完整名称，可以有两种方法： Import：例如：Import java.util.ArrayList Type 或者在代码中声明，太麻烦了 包的一个重要作用就是错开相同命名的类，可以通过不同的包名来区分 javax开头的包，以前是拓展，现在是标准了 不必import进String类或System类：因为java.lang是个预先被引用的包。这俩是独一无二的class 引用类型使用步骤导包使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。 格式： 1import 包名.类名; 创建对象使用该类的构造方法，创建一个该类的对象。 格式： 1数据类型 变量名 = new 数据类型(参数列表); 调用方法调用该类的成员方法，完成指定功能。 格式： 1变量名.方法名(); 匿名对象创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。匿名对象 ：没有变量名的对象。 格式： 1new 类名(参数列表); 应用场景 创建匿名对象直接调用方法，没有变量名。 1new Scanner(System.in).nextInt(); 一旦调用两次方法，就是创建了两个对象，造成浪费，请看如下代码。 12new Scanner(System.in).nextInt();new Scanner(System.in).nextInt(); 小贴士：一个匿名对象，只能使用一次。 匿名对象可以作为方法的参数和返回值 作为参数： 123456789101112class Test &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = new Scanner(System.in); input(sc); //匿名对象作为方法接收的参数 input(new Scanner(System.in)); &#125; public static void input(Scanner sc)&#123; System.out.println(sc); &#125;&#125; 作为返回值： 12345678910111213class Test2 &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = getScanner(); &#125; public static Scanner getScanner()&#123; //普通方式 //Scanner sc = new Scanner(System.in); //return sc; //匿名对象作为方法返回值 return new Scanner(System.in); &#125;&#125; 2、ArrayListArrayList是java函数库的一个类。 ArrayList不能存primitive主数据类型，但是可以用包装类包装一下就行，而且java5之后自动进行包装。 ArrayList与数组的区别： 1、创建不用指定大小 2、插入不用指定位置 remove indexof add isempty 3、布尔表达式短运算符（&amp;&amp;） 下面是一个小技巧，可以避免调用内容为null的指针变量的方法 if(refvar != null &amp;&amp; refvar.isVaildType()){ //执行操作 } 长运算符（&amp;，|） 通常用来做位的运算 4、Scanner类一个可以解析基本类型和字符串的简单文本扫描器。 12345678910111213//1. 导包import java.util.Scanner;public class Demo01_Scanner &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Scanner sc = new Scanner(System.in); //3. 接收数据 System.out.println("请录入一个整数："); int i = sc.nextInt(); //4. 输出数据 System.out.println("i:"+i); &#125;&#125; 5、Random类此类的实例用于生成伪随机数。 1234567891011121314//1. 导包import java.util.Random;public class Demo01_Random &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Random r = new Random(); for(int i = 0; i &lt; 3; i++)&#123; //3. 随机生成一个数据 int number = r.nextInt(10); //4. 输出数据 System.out.println("number:"+ number); &#125; &#125;&#125; 6、String类6.1 String类特点 字符串不变：字符串的值在创建后不能被更改 1234String s1 = "abc";s1 += "d";System.out.println(s1); // "abcd"// 内存中有"abc"，"abcd"两个对象，s1从指向"abc"，改变指向，指向了"abcd"。 因为String对象是不可变的，所以它们可以被共享 123String s1 = "abc";String s2 = "abc";// 内存中只有一个"abc"对象被创建，同时被s1和s2共享。 “abc” 等效于 char[] data={ ‘a’ , ‘b’ , ‘c’ } 。 123456例如：String str = "abc";相当于：char data[] = &#123;'a', 'b', 'c'&#125;;String str = new String(data);// String底层是靠字符数组实现的。 6.2 基本类型转换为String 基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： 1基本类型直接与””相连接即可；如：34+&quot;&quot; String转换成对应的基本类型 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt("100"); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。 7、StringBuilder类7.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = "Hello"; s += "World"; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWord 。 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 7.2 StringBuilder概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 7.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder("itcast"); System.out.println(sb2); // itcast &#125;&#125; 7.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 12345678910111213141516171819202122public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append("hello"); //对比一下 System.out.println("builder:"+builder); System.out.println("builder2:"+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append("hello"); builder.append("world"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append("hello").append("world").append(true).append(100); System.out.println("builder:"+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder("Hello").append("World").append("Java"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 8、时间日期类8.1 Date类概述java.util.Date类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 8.2 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); &#125; &#125; 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat("yyyy年MM月dd日"); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat("yyyy年MM月dd日"); String str = "2018年12月11日"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 8.3 练习请使用日期时间相关的API，计算出一个人已经出生了多少天。 思路： 1.获取当前时间对应的毫秒值 2.获取自己出生日期对应的毫秒值 3.两个时间相减（当前时间– 出生日期） 代码实现： 123456789101112131415161718192021public static void function() throws Exception &#123; System.out.println("请输入出生日期 格式 YYYY-MM-dd"); // 获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); // 将字符串日期,转成Date对象 // 创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); // 调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); // 获取今天的日期对象 Date todayDate = new Date(); // 将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long secone = todaySecond-birthdaySecond; if (secone &lt; 0)&#123; System.out.println("还没出生呢"); &#125; else &#123; System.out.println(secone/1000/60/60/24); &#125;&#125; 8.4 Calendar类概念日历我们都见过 java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 123456789101112131415import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); &#125; &#125; 123456789import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2020年1月17日 &#125;&#125; add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 123456789101112import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2015年1月18日; &#125;&#125; getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 9、System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 9.1 currentTimeMillis方法实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 12345678import java.util.Date;public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; 练习验证for循环打印数字1-9999所需要使用的时间（毫秒） 12345678910public class SystemTest1 &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; long end = System.currentTimeMillis(); System.out.println("共耗时毫秒：" + (end - start)); &#125;&#125; 9.2 arraycopy方法 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 练习将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] 12345678910111213import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习（2）多态]]></title>
    <url>%2F2019%2F02%2F06%2Fjava%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[java学习（2）多态一、继承与多态继承（extends）继承的关系意味着子类继承父类的方法。当我们提及类的“类的成员”，意思是实例变量和方法。 子类的方法可以对父类的方法进行覆盖override 子类方法的调用一定是调层次树最下端的 A是B的父类，B是C的父类，那么A是C的父类 关于判断继承设计是否是正确的，要使用IS-A（感觉还是不太懂啊） 子类中打算引用父类的方法然后再加上额外的行为： public void roam(){ super.roam(); //程序会先执行super版的roam()然后再回来执行sub版自定义的行为或功能 //my own roam stuff } 继承让你可以确保某个父型之下的所有类都会有父型所持有的全部方法 多态在多态下，引用与对象可以是不同的类型。 Animal mydog = new Dog();//引用变量的类型是Animal，而对象是Dog 运用多态时，引用类型可以是实际对象类型的父类 参数和返回类型也可以是多态！ 一个类不能被子类继承：（内部类、3种方法） 1、存取控制，不标记公有，这样只能被同一个包的类继承 2、使用final修饰符，表示继承树的末端，不能被继承 3、让类只拥有private的构造程序 覆盖如果你希望类里的特定方法不能被覆盖，可以加上final修饰符 覆盖：方法必须和父类有相同的参数和返回值类型或其子类，不然无法覆盖；方法的存取权限也必须相同或者更为开放，不能把公有的声明为私有的。 重载（overload）重载的方法只是刚好有相同的名字的不同的方法，与继承或多态无关。 返回类型可以不同，只要使用的不同的参数即可。 可以更改存取权限， 二、深入多态多态多态的体现多态体现的格式： 12父类类型 变量名 = new 子类对象；变量名.方法名(); 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。 代码如下： 12Fu f = new Zi();f.method(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。 为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下： 123变量名 instanceof 数据类型如果变量属于该数据类型，返回true。如果变量不属于该数据类型，返回false。 抽象类关键词abstract 抽象类代表没有人能够创建出该类的实例，除了被继承过，就没有其他的用途了 抽象的方法：代表此方法一定要被覆盖过。抽象的方法没有实体！如果你声明了一个抽象的方法，那么该类也必须标记为抽象的。你不能在非抽象类中拥有抽象的方法。 子类必须实现父类的抽象方法 Object所有类都是从Object中继承出来的 没有直接继承过其他类的类会是隐含的继承对象。 Object不是抽象类 Object类主要有两个作用：1、多态，让方法可以应付多种类型的机制；2、用在线程的同步化上面 任何从ArrayList取出的东西都会被当做Object类型的引用而不管它原来是什么，但是可以强转回来 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; 接口（关键词：interface）java的接口的所有方法都是抽象的， 接口解决了java不允许继承多个父类的问题 不同的继承树的类可以有相同的接口 类可以实现多个接口 super关键字可以让子类调用父类的方法 接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。 引用数据类型：数组，类，接口。 接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。 静态方法使用静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用 私有方法的使用私有方法：只有默认方法可以调用。私有静态方法：默认方法和静态方法可以调用 接口的多实现在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。实现格式： 1234class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... &#123;// 重写接口中抽象方法【必须】// 重写接口中默认方法【不重名时可选】&#125; [ ]： 表示可选操作。]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习（3）构造器、数字与静态、异常处理]]></title>
    <url>%2F2019%2F02%2F06%2Fjava%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、构造器和垃圾收集器1、栈与堆方法的调用和局部变量在栈，所有的对象在堆 栈顶上的方法是目前正在执行的。 对象的引用变量（就是遥控器）存放在栈上，而对象则存放到堆上 实例变量存放在所属对象的堆空间上。 2、构造函数构造函数并不是一个方法 构造函数没有返回的类型，并且名称要与类名一致 分辨方法和构造函数的办法就是是否有返回类型 如果写了一个带有参数的构造函数，那么应该再写一个没有参数的构造函数 构造函数重载，编译器看的是参数的类型和顺序，不是参数的名字 实例变量有默认值，局部变量没有 构造函数可以是私有的 在创建新对象时，所有继承下来的构造函数都会执行。 抽象类作为父类，他的构造函数也会在具体子类创建出实例时执行。 调用父类的构造函数使用的是：super(); 如果我们在子类的构造函数里面不写，那么编译器会自动帮我们添加，只不过添加的是没有参数的版本 使用this()来从某个构造函数调用同一个类的另外一个构造函数，this()只能用在构造函数中，且必须是第一行语句。super()和this()不能兼得。 3、对象的生命周期当最后一个引用消失的时候，对象就会变成可回收的。 对null引用执行圆点运算符会在执行期遇到NullPointerException这样的错误 二、数字与静态1、Math方法最接近全局的方法。 这个类中的所有方法都不需要实例变量值，因为这些方法是静态的。 1.1 概述java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 1.2 基本运算方法 public static double abs(double a) ：返回 double 值的绝对值。 12double d1 = Math.abs(‐5); //d1的值为5double d2 = Math.abs(5); //d2的值为5 public static double ceil(double a) ：返回大于等于参数的最小的整数。 123double d1 = Math.ceil(3.3); //d1的值为 4.0double d2 = Math.ceil(‐3.3); //d2的值为 ‐3.0double d3 = Math.ceil(5.1); //d3的值为 6.0 public static double floor(double a) ：返回小于等于参数最大的整数。 123double d1 = Math.floor(3.3); //d1的值为3.0double d2 = Math.floor(‐3.3); //d2的值为‐4.0double d3 = Math.floor(5.1); //d3的值为 5.0 public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法) 12long d1 = Math.round(5.5); //d1的值为6.0long d2 = Math.round(5.4); //d2的值为5.0 2、静态（static）静态的方法是以类名来调用的，静态的方法不需要类的实例 可以使用私有的构造函数来限制非抽象类被初始化 静态的方法不能调用非静态的变量，也不能调用非静态的方法 以引用变量名调用静态方法的程序代码可以实现，但是不推荐使用 静态变量的值对于所有的实例来说都相同，同一类所有的实例共享一份静态变量 静态变量会在该类的任何静态方法执行前就初始化。 小贴士：静态方法只能访问静态成员。 被static修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。 3、finalfinal的变量代表你不能改变它的值。 final的方法代表你不能覆盖掉该方法。 final的类代表你不能继承该类（也就是创建子类） 3.1 总结一下（重要）变量用static代表这是能够修改的全局变量，变量用final代表这是不能修改值的变量（可以看成是全局的），abstract不能修饰变量。 类用abstract修饰表示是类本身不能声明实例，只能由子类来声明实例；类用final修饰表示类不能有子类来继承；static不能修饰类。 方法用abstract修饰那么该类也是abstract，表示该方法必须由子类覆盖；方法用final代表子类中不能覆盖该方法；方法用static表示该方法的调用时用类名来实现的，不需要实例。 4、autoboxing（自动装箱）包装类型（Interger）和primitive主数据（int）可以相互转换 可以用在很多的地方：方法的参数、返回值、Boolean表达式、数值运算、赋值 包装也有静态的实用性方法！（将String转换成primitive主数据类型：Integer.parseInt）、（将primitive主数据类型转换为String Double.toString） 数值转换成String，最简单的方法是将数字接上现有的String String doubleString = “ ” + d; 4.1 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—-&gt;包装对象 12Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 1int num = i.intValue(); 4.2 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 5、数字的格式化调用静态的String.format()并传入值与格式设定 格式化说明的格式：%[argument number] [flags] [width] [.precious] type format()函数不是用的重载实现的，而是使用的java的一项新的功能：可变参数列表 6、日期Date Today = new Date(); String.format(“%tA, %&lt;tB %&lt;td”, Today); 操作日期可以使用：java.util.Calendar Calendar cal = Calendar.getInstance(); 7、静态import可以少打几行代码，但是会使代码变得难以阅读 三、异常处理使用try/catch块告诉编译器调用方法有风险的 异常时一种Exception类型的对象 方法可以抓住其他方法所抛出的异常。异常总是会丢给调用方。会抛出异常的方法必须要声明他有可能会这么做 finally：无论如何都要执行的部分 异常时多态的，以异常的父类来声明会抛出的异常 如果不想处理异常，可以把它duck掉来避开，但这是在踢皮球 异常处理规则：如果只带有finally的try必须要声明异常]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习（1）java基础]]></title>
    <url>%2F2019%2F02%2F06%2Fjava%E5%AD%A6%E4%B9%A0%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[java学习（4）内部类内部类可以使用外部类的所有方法和变量，就算是私有的也一样。 内部类的实例一定会绑在外部类的实例上，该内部类实例只能存取绑在的那个外部类的实例的函数和变量。 创建内部类1234567891011121314class Myouter&#123; private int x;//外部类有一个变量 MyInner inner = new MyInner();//创建内部类的实例 public void doStuff()&#123; inner.go();//调用内部类的函数 &#125; class MyInner&#123; void go()&#123; x=42;//内部类可以使用外部类的变量 &#125; &#125;&#125; 文件的输入/输出将序列化对象写入文件 12345678910//创建出FileOutputStreamFileOutputStream fileStream = new FileOutputStream("MyGame.ser");//创建ObjectOutputStreamObjectOutputStream os = new ObjectOutputStream(fileStream);//写入对象os.writeObject(characterOne);os.writeObject(characterTwo);os.writeObject(characterThree);//关闭ObjectOutputStreamos.close; 将字符串写入文本文件 1234567891011121314151617import java.io.*;class WriteFile&#123; public static void main(String[] args)&#123; //输入输出等相关的操作都必须放到try/catch中 try&#123; //Foo.txt如果不存在会被创建 FileWriter writer = new FileWriter("Foo.txt"); //以字符串作为参数 writer,write("hello foo"); //记得关掉 writer.close(); &#125;catch(IOException e)&#123; ex.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习（1）java基础]]></title>
    <url>%2F2019%2F02%2F06%2Fjava%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89java%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[java学习系列是用来记录这次的java学习总结的，希望可以坚持下去。 这次主要是看Head First Java 这本书的，感觉这个书确实厉害。虽然说有很多的图会减少很多的阅读的烦躁感，但是最重要的还是作者用很少的文字却讲了很多java中的注意问题，说实话我其实在这之前已经用过java去开发一些项目了，算不上是一个新手，但是阅读这本书还是让我收获到了很多的新的知识 1、进入java世界java工作方式源代码：编写源代码程序 编译器：检查源代码的错误 输出：编译器会产出字节码，也就是看到的.class文件 java虚拟机（JVM）：用来运行.class文件，这样就可以实现跨平台 ​ jdk、jre和jvm关系图 标识符标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符 标识符不能以数字开头。 2、类与对象实例变量：对象本身已知的事物 方法：对象可以执行的动作 类不是对象，类是对象的蓝图 圆点运算符（.）：此运算符能让你存取对象的状态与行为 main()的两种用途：测试真正的类；启动你的java应用程序 java的面向对象概念中没有全局变量， 类中变量全局变量和局部变量的区别： 在类中的位置不同 重点成员变量：类中，方法外局部变量：方法中或者方法声明上(形式参数) 作用范围不一样 重点成员变量：类中局部变量：方法中 初始化值的不同 重点成员变量：有默认值局部变量：没有默认值。必须先定义，赋值，最后使用 在内存中的位置不同 了解成员变量：堆内存局部变量：栈内存 生命周期不同 了解成员变量：随着对象的创建而存在，随着对象的消失而消失局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 3、数据类型&amp;运算符变量变量有两种：primitive主数据类型和引用 基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。 引用数据类型：包括 类 、 数组 、 接口 基本数据类型四类八种基本数据类型： 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整型 int（默认） 4个字节 -231次方~2的31次方-1 长整型 long 8个字节 -2的63次方~2的63次方-1 单精度浮点数 float 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double（默认） 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true，false Java中的默认类型：整数类型是 int 、浮点类型是 double 。 引用数据类型事实上没有对象变量的存在，只有引用到对象的变量。对象引用变量保存的是存取对象的方法。 primitive主数据类型变量是以字节来代表实际的变量值，但对象引用变量却是以字节来表示取得对象的方法。（你可以将引用变量想象成遥控器） 声明一个引用变量 Dog myDog = new Dog(); 代表取得Dog对象的方法以字节形式放进变量。对象本身并没有放进变量中！ 数组也是对象，primitive主数据类型有8种，声明： int[] nums = new int[7]; java注重类型，一旦数组被声明出来，你就只能装入所声明类型的元素。 数据类型转换自动转换编译器不允许将大容量数据类型的内容存在小容量数据类型的内容 自动转换：将 取值范围小的类型 自动提升为 取值范围大的类型 。 范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double 强制转换 强制类型转换：将 取值范围大的类型 强制转换成 取值范围小的类型 。 自动转换时java自动执行，强制转换时我们自己手动执行。 转换格式：数据类型 变量名 = （数据类型）被转数据值； 注意：浮点转成整数，直接取消小数点，可能造成数据损失精度。int 强制转成 short 砍掉2个字节，可能造成数据丢失。 运算符三元运算符三元运算符格式：数据类型 变量名 = 布尔类型表达式？结果1：结果2 三元运算符计算方式： 布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。 布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量 注意：s += 1 逻辑上看作是 s = s + 1 计算结果被提升为int类型，再向short类型赋值时发生错误，因为不能将取值范围大的类型赋值到取值范围小的类型。但是， s=s+1进行两次运算 ， += 是一个运算符，只运算一次，并带有强制转换的特点，也就是说 s += 1 就是 s = (short)(s + 1) ，因此程序没有问题编译通过，运行结果是2 数组三种定义方式 数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度]; 1int[] arr = new int[3]; 数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3…}; 1int[] arr = new int[]&#123;1,2,3,4,5&#125;; 数据类型[] 数组名 = {元素1,元素2,元素3…}; 1int[] arr = &#123;1,2,3,4,5&#125;; 在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码 数组作为方法参数传递，传递的参数是数组内存的地址。 数组作为方法的返回值，返回的是数组的内存地址 方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值 4、对象的行为记住：类所描述的是对象知道什么与执行什么？ 方法会运用形参，调用的一方会传入实参 java是通过值传递的，也就是说通过拷贝传递的。 封装封装的目的和意义为了安全 所谓的封装就是将类的变量和方法标记上修饰符（private/public） this关键字this代表所在类的当前对象的引用（地址值），即对象自己的引用。 记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。 实例变量永远都会有默认值。如果你没有明确的赋值给实例变量，或者没有调用setter，实例变量还是会有值的。但是局部变量没有默认值！如果在变量被初始化前使用的话，编译器会显示错误。 变量的比较使用==来比较两个primitive主数据类型，或者判断两个是否引用同一个对象。使用equals()来判断两个对象是否在意义上相等（例如两个String类型字符串判断内容是否相等） equal函数方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： tips：Object类当中的hashCode等其他方法，今后学习。 5、超强力方法将string转int：int a = Integer.parseInt(“3”); 将int转string的三种方法：1、String.valueOf(i) ；2、 Integer.toString(i) ；3、 i+”” Math.random()会返回一个0到1之间的数 for(String name : nameArray){} 在其他程序语言背景中，这种循环又称为“for each”或“for in”循环]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（8）vue路由]]></title>
    <url>%2F2019%2F02%2F01%2F%EF%BC%888%EF%BC%89router%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[vue路由什么是路由 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 使用vue-router 导入 vue-router 组件类库 12&lt;!-- 1. 安装 vue-router 路由模块 --&gt;&lt;script src="./lib/vue-router-3.0.1.js"&gt;&lt;/script&gt; 使用 router-link 组件来导航 router-link 默认渲染为一个a 标签，如果想要渲染成span标签，可以使用tag=“span”进行设置 12&lt;router-link to="/login" tag="span"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 这是 vue-router 提供的元素，专门用来 当作占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去。 所以： 我们可以把 router-view 认为是一个占位符。 注意：这里的transition是给路由添加了动画。 123&lt;transition mode="out-in"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 创建使用Vue.extend创建组件 12345678// 组件的模板对象var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;var register = &#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125; 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 每个路由规则，都是一个对象，这个规则对象，身上，有两个必须的属性： 属性1 是 path， 表示监听 哪个路由链接地址； 属性2 是 component， 表示，如果 路由是前面匹配到的 path ，则展示 component 属性对应的那个组件 注意： component 的属性值，必须是一个 组件的模板对象， 不能是 组件的引用名称； 123456789var routerObj = new VueRouter(&#123; // route // 这个配置对象中的 route 表示 【路由匹配规则】 的意思 routes: [ // 路由匹配规则 &#123; path: '/', redirect: '/login' &#125;, // 这里的 redirect 和 Node 中的 redirect 完全是两码事 &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ], linkActiveClass: 'myactive'&#125;) 使用 router 属性来使用路由规则 123456var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件&#125;); router-link使用 使用tag指定router-link渲染的标签类型 1&lt;router-link to="/login" tag="span"&gt;登录&lt;/router-link&gt; redirect重定向这样就可以解决一开始打开网页时，没有匹配的组件；而且当不会产生匹配到login组件，但是URL却显示“/”而不是显示“/login”的问题。 12345678var routerObj = new VueRouter(&#123; routes: [ // 路由匹配规则 // &#123; path: '/', component: login &#125;, &#123; path: '/', redirect: '/login' &#125;, // 这里的 redirect 和 Node 中的 redirect 完全是两码事 &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ],&#125;) 设置路由高亮可以在style中设置router-link-active的属性，这个应该是默认的 12345678.router-link-active&#123; color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green;&#125; 当然你可以自己定义名称，然后在style中去定义,例如定义了“myactive” style： 123456789.router-link-active,.myactive &#123; color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green;&#125; js:这里面的“linkActiveClass”就是自定义的高亮显示设置命名 12345678var routerObj = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, // 这里的 redirect 和 Node 中的 redirect 完全是两码事 &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ], linkActiveClass: 'myactive'&#125;) 路由切换动画和组件的动画一样，在外层套上一个 123&lt;transition mode="out-in"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; 在style里面设置好 12345678910.v-enter,.v-leave-to &#123; opacity: 0; transform: translateX(140px);&#125;.v-enter-active,.v-leave-active &#123; transition: all 0.5s ease;&#125; 路由传参query方式 如果在路由中，使用 查询字符串，给路由传递参数，则 不需要修改 路由规则的 path 属性 1&lt;router-link to=&quot;/login?id=10&amp;name=zs&quot;&gt;登录&lt;/router-link&gt; $route.query.”变量名”就可以访问 123456789101112var login = &#123; template: '&lt;h1&gt;登录 --- &#123;&#123; $route.query.id &#125;&#125; --- &#123;&#123; $route.query.name &#125;&#125;&lt;/h1&gt;', data()&#123; return &#123; msg: '123' &#125; &#125;, created()&#123; // 组件的生命周期钩子函数 // console.log(this.$route) // console.log(this.$route.query.id) &#125;&#125; login这的path不用改变 123456var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ]&#125;) params方式传参方式 1&lt;router-link to="/login/12/ls"&gt;登录&lt;/router-link&gt; 获取方式没有区别 1234567891011var login = &#123; template: '&lt;h1&gt;登录 --- &#123;&#123; $route.params.id &#125;&#125; --- &#123;&#123; $route.params.name &#125;&#125;&lt;/h1&gt;', data()&#123; return &#123; msg: '123' &#125; &#125;, created()&#123; // 组件的生命周期钩子函数 console.log(this.$route.params.id) &#125;&#125; path需要匹配 123456var router = new VueRouter(&#123; routes: [ &#123; path: '/login/:id/:name', component: login &#125;, &#123; path: '/register', component: register &#125; ]&#125;) 路由嵌套先定义好父组件account 123456789101112131415161718&lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;template id="tmpl"&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;router-link to="/account/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/account/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 定义父子组件的模板 1234567891011var account = &#123; template: '#tmpl'&#125;var login = &#123; template: '&lt;h3&gt;登录&lt;/h3&gt;'&#125;var register = &#123; template: '&lt;h3&gt;注册&lt;/h3&gt;'&#125; 定义router 使用 children 属性，实现子路由，同时，子路由的 path 前面，不要带 / ，否则永远以根路径开始请求，这样不方便我们用户去理解URL地址 注意不要写成注释中的代码，子组件的注册必须写在父组件的里面。 1234567891011121314var router = new VueRouter(&#123; routes: [ &#123; path: '/account', component: account, children: [ &#123; path: 'login', component: login &#125;, &#123; path: 'register', component: register &#125; ] &#125; // &#123; path: '/account/login', component: login &#125;, // &#123; path: '/account/register', component: register &#125; ]&#125;) 实例：使用命名视图实现经典布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script src="./lib/vue-router-3.0.1.js"&gt;&lt;/script&gt; &lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; .header &#123; background-color: orange; height: 80px; &#125; h1 &#123; margin: 0; padding: 0; font-size: 16px; &#125; .container &#123; display: flex; height: 600px; &#125; .left &#123; background-color: lightgreen; flex: 2; &#125; .main &#123; background-color: lightpink; flex: 8; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="container"&gt; &lt;router-view name="left"&gt;&lt;/router-view&gt; &lt;router-view name="main"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var header = &#123; template: '&lt;h1 class="header"&gt;Header头部区域&lt;/h1&gt;' &#125; var leftBox = &#123; template: '&lt;h1 class="left"&gt;Left侧边栏区域&lt;/h1&gt;' &#125; var mainBox = &#123; template: '&lt;h1 class="main"&gt;mainBox主体区域&lt;/h1&gt;' &#125; // 创建路由对象 var router = new VueRouter(&#123; routes: [ /* &#123; path: '/', component: header &#125;, &#123; path: '/left', component: leftBox &#125;, &#123; path: '/main', component: mainBox &#125; */ &#123; path: '/', components: &#123; 'default': header, 'left': leftBox, 'main': mainBox &#125; &#125; ] &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（7）vue组件]]></title>
    <url>%2F2019%2F02%2F01%2F%EF%BC%887%EF%BC%89vue%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[vue组件组件概念什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 全局vue组件定义1、使用 Vue.extend 配合 Vue.component第一步，使用 Vue.extend 来创建全局的Vue组件 1234var com1 = Vue.extend(&#123; // 通过 template 属性，指定了组件要展示的HTML结构 template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;' &#125;) 第二步，使用 Vue.component（’组件的名称’, 创建出来的组件模板对象） 如果使用 Vue.component 定义全局组件的时候，组件名称使用了 驼峰命名，则在引用组件的时候，需要把 大写的驼峰改为小写的字母，同时，两个单词之前，使用 - 链接； script部分： 1Vue.component('myCom1', com1) html部分： 1&lt;my-com1&gt;&lt;/my-com1&gt; 如果不使用驼峰,则直接拿名称来使用即可; script部分： 1Vue.component('mycom1', com1) html部分： 1&lt;mycom1&gt;&lt;/mycom1&gt; 2、直接使用 Vue.component相较于第一种方法，将Vue.extend 构建template的步骤直接放到Vue.component里面，更为简单 12345// Vue.component 第一个参数:组件的名称,将来在引用组件的时候,就是一个 标签形式 来引入 它的// 第二个参数: Vue.extend 创建的组件 ,其中 template 就是组件将来要展示的HTML内容Vue.component('mycom1', Vue.extend(&#123; template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;'&#125;)) 其实还可以更简单一点， 1234// 注意:不论是哪种方式创建出来的组件,组件的 template 属性指向的模板内容,必须有且只能有唯一的一个根元素Vue.component('mycom2', &#123; template: '&lt;div&gt;&lt;h3&gt;这是直接使用 Vue.component 创建出来的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt; &lt;/div&gt;'&#125;) 但是这种方法有一个问题就是，写在template中的HTML代码IDE没有办法进行辅助提示、排版等功能，影响工作效率。 3、将模板字符串，定义到script标签种先在里面定义好组件，设置好id；然后在Vue.component中引用该 html部分： 12345678910&lt;div id="app"&gt; &lt;mycom3&gt;&lt;/mycom3&gt;&lt;/div&gt;&lt;!-- 在 被控制的 #app 外面,使用 template 元素,定义组件的HTML模板结构 --&gt;&lt;template id="tmpl"&gt; &lt;div&gt; &lt;h1&gt;这是通过 template 元素,在外部定义的组件结构,这个方式,有代码的只能提示和高亮&lt;/h1&gt; &lt;h4&gt;好用,不错!&lt;/h4&gt; &lt;/div&gt;&lt;/template&gt; 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ script部分： 123Vue.component('mycom3', &#123; template: '#tmpl'&#125;) 第三种方法最好，推荐使用。 私有组件定义定义私有的组件，就需要在VM实例中的components中去定义。 vm实例： 123456789101112131415161718192021var vm2 = new Vue(&#123; el: '#app2', data: &#123;&#125;, methods: &#123;&#125;, filters: &#123;&#125;, directives: &#123;&#125;, components: &#123; // 定义实例内部私有组件的 login: &#123; template: '#tmpl2' &#125; &#125;, beforeCreate() &#123; &#125;, created() &#123; &#125;, beforeMount() &#123; &#125;, mounted() &#123; &#125;, beforeUpdate() &#123; &#125;, updated() &#123; &#125;, beforeDestroy() &#123; &#125;, destroyed() &#123; &#125;&#125;) HTML： 123456&lt;div id="app2"&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;&lt;template id="tmpl2"&gt; &lt;h1&gt;这是私有的 login 组件&lt;/h1&gt;&lt;/template&gt; 组件中的data 组件可以有自己的 data 数据 组件的 data 和 实例的 data 有点不一样,实例中的 data 可以为一个对象,但是 组件中的 data 必须是一个方法 组件中的 data 除了必须为一个方法之外,这个方法内部,还必须返回一个对象才行; 组件中 的data 数据,使用方式,和实例中的 data 使用方式完全一样!!! 12345678Vue.component('mycom1', &#123; template: '&lt;h1&gt;这是全局组件 --- &#123;&#123;msg&#125;&#125;&lt;/h1&gt;', data: function () &#123; return &#123; msg: '这是组件的中data定义的数据' &#125; &#125;&#125;) 组件切换1、v-if和v-else结合flag示例是有两个链接登录和注册，点击不同的链接显示不同的组件。 HTML： 12345&lt;a href="" @click.prevent="flag=true"&gt;登录&lt;/a&gt;&lt;a href="" @click.prevent="flag=false"&gt;注册&lt;/a&gt;&lt;login v-if="flag"&gt;&lt;/login&gt;&lt;register v-else="flag"&gt;&lt;/register&gt; script： 12345678910111213141516Vue.component('login', &#123; template: '&lt;h3&gt;登录组件&lt;/h3&gt;'&#125;)Vue.component('register', &#123; template: '&lt;h3&gt;注册组件&lt;/h3&gt;'&#125;)// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125;&#125;); 2、vue提供component元素提供组件的切换通过设置里面的is属性值为组件名称，起到切换组件的作用。 HTML部分： 123456&lt;a href="" @click.prevent="comName='login'"&gt;登录&lt;/a&gt;&lt;a href="" @click.prevent="comName='register'"&gt;注册&lt;/a&gt;&lt;!-- Vue提供了 component ,来展示对应名称的组件 --&gt;&lt;!-- component 是一个占位符, :is 属性,可以用来指定要展示的组件的名称 --&gt;&lt;component :is="comName"&gt;&lt;/component&gt; script部分： 1234567891011121314151617// 组件名称是 字符串Vue.component('login', &#123; template: '&lt;h3&gt;登录组件&lt;/h3&gt;'&#125;)Vue.component('register', &#123; template: '&lt;h3&gt;注册组件&lt;/h3&gt;'&#125;)// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; comName: 'login' // 当前 component 中的 :is 绑定的组件的名称 &#125;, methods: &#123;&#125;&#125;); 3、添加动画实际上就是套上，在css中设置动画效果 HTML： 1234&lt;!-- 通过 mode 属性,设置组件切换时候的 模式 --&gt;&lt;transition mode="out-in"&gt; &lt;component :is="comName"&gt;&lt;/component&gt;&lt;/transition&gt; CSS： 123456789101112&lt;style&gt;.v-enter,.v-leave-to &#123; opacity: 0; transform: translateX(150px);&#125;.v-enter-active,.v-leave-active &#123; transition: all 0.5s ease;&#125;&lt;/style&gt; 组件传值父组件向子组件传值 子组件中，默认无法访问到 父组件中的 data 上的数据 和 methods 中的方法 父组件，可以在引用子组件的时候， 通过 属性绑定（v-bind:） 的形式, 把 需要传递给 子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用。 把父组件传递过来的 parentmsg 属性，先在 props 数组中，定义一下，这样，才能使用这个数据 HTML： 12//parentmsg是需要在props中定义的，msg是父组件的变量 &lt;com1 v-bind:parentmsg="msg"&gt;&lt;/com1&gt; VM： 12345678910111213141516171819202122232425262728var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123 啊-父组件中的数据' &#125;, methods: &#123;&#125;, components: &#123; com1: &#123; data() &#123; return &#123; title: '123', content: 'qqq' &#125; &#125;, template: '&lt;h1 @click="change"&gt;这是子组件 --- &#123;&#123; parentmsg &#125;&#125;&lt;/h1&gt;', props: ['parentmsg'], directives: &#123;&#125;, filters: &#123;&#125;, components: &#123;&#125;, methods: &#123; change() &#123; this.parentmsg = '被修改了' &#125; &#125; &#125; &#125;&#125;); data和props的区别子组件中的 data 数据，并不是通过 父组件传递过来的，而是子组件自身私有的，比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上； data 上的数据，都是可读可写的； 组件中的 所有 props 中的数据，都是通过 父组件传递给子组件的 props 中的数据，都是只读的，无法重新赋值 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;com2 @func="show"&gt;&lt;/com2&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 1this.$emit('func', this.sonmsg) VM： 1234567891011121314151617181920212223242526272829303132333435363738// 定义了一个字面量类型的 组件模板对象 var com2 = &#123; template: '#tmpl', // 通过指定了一个 Id, 表示 说，要去加载 这个指定Id的 template 元素中的内容，当作 组件的HTML结构 data() &#123; return &#123; sonmsg: &#123; name: '小头儿子', age: 6 &#125; &#125; &#125;, methods: &#123; myclick() &#123; // 当点击子组件的按钮的时候，如何 拿到 父组件传递过来的 func 方法，并调用这个方法？？？ // emit 英文原意： 是触发，调用、发射的意思 // this.$emit('func123', 123, 456) this.$emit('func', this.sonmsg) &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; datamsgFormSon: null &#125;, methods: &#123; show(data) &#123; // console.log('调用了父组件身上的 show 方法: --- ' + data) // console.log(data); this.datamsgFormSon = data &#125; &#125;, components: &#123; com2 // com2: com2 &#125; &#125;); 组件案例：评论发表&amp;显示使用localStorage 存储数据分析：发表评论的业务逻辑 1. 评论数据存到哪里去？？？ 存放到了 localStorage 中 localStorage.setItem(&apos;cmts&apos;, &apos;&apos;) 出一个最新的评论数据对象 2. 先组织出一个最新的评论数据对象 3. 想办法，把 第二步中，得到的评论对象，保存到 localStorage 中： 3.1 localStorage 只支持存放字符串数据， 要先调用 JSON.stringify 3.2 在保存 最新的 评论数据之前，要先从 localStorage 获取到之前的评论数据（string）， 转换为 一个 数组对象， 然后，把最新的评论， push 到这个数组 3.3 如果获取到的 localStorage 中的 评论字符串，为空不存在， 则 可以 返回一个 &apos;[]&apos; 让 JSON.parse 去转换 3.4 把 最新的 评论列表数组，再次调用 JSON.stringify 转为 数组字符串，然后调用 localStorage.setItem() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./lib/bootstrap-3.3.7.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;cmt-box @func="loadComments"&gt;&lt;/cmt-box&gt; &lt;ul class="list-group"&gt; &lt;li class="list-group-item" v-for="item in list" :key="item.id"&gt; &lt;span class="badge"&gt;评论人： &#123;&#123; item.user &#125;&#125;&lt;/span&gt; &#123;&#123; item.content &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;template id="tmpl"&gt; &lt;div&gt; &lt;div class="form-group"&gt; &lt;label&gt;评论人：&lt;/label&gt; &lt;input type="text" class="form-control" v-model="user"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;评论内容：&lt;/label&gt; &lt;textarea class="form-control" v-model="content"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;input type="button" value="发表评论" class="btn btn-primary" @click="postComment"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var commentBox = &#123; data() &#123; return &#123; user: '', content: '' &#125; &#125;, template: '#tmpl', methods: &#123; postComment() &#123; // 发表评论的方法 var comment = &#123; id: Date.now(), user: this.user, content: this.content &#125; // 从 localStorage 中获取所有的评论 var list = JSON.parse(localStorage.getItem('cmts') || '[]') list.unshift(comment) // 重新保存最新的 评论数据 localStorage.setItem('cmts', JSON.stringify(list)) this.user = this.content = '' // this.loadComments() // ????? this.$emit('func') &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [ &#123; id: Date.now(), user: '李白', content: '天生我材必有用' &#125;, &#123; id: Date.now(), user: '江小白', content: '劝君更尽一杯酒' &#125;, &#123; id: Date.now(), user: '小马', content: '我姓马， 风吹草低见牛羊的马' &#125; ] &#125;, beforeCreate()&#123; // 注意：这里不能调用 loadComments 方法，因为在执行这个钩子函数的时候，data 和 methods 都还没有被初始化好 &#125;, created()&#123; this.loadComments() &#125;, methods: &#123; loadComments() &#123; // 从本地的 localStorage 中，加载评论列表 var list = JSON.parse(localStorage.getItem('cmts') || '[]') this.list = list &#125; &#125;, components: &#123; 'cmt-box': commentBox &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果展示： ref获取dom元素和组件 this.$refs.&quot;组件名称&quot;.方法/变量 HTML： 123&lt;h3 id="myh3" ref="myh3"&gt;哈哈哈， 今天天气太好了！！！&lt;/h3&gt;&lt;login ref="mylogin"&gt;&lt;/login&gt; script： 123456789101112131415161718var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // console.log(document.getElementById('myh3').innerText) // ref 是 英文单词 【reference】 值类型 和 引用类型 referenceError console.log(this.$refs.myh3.innerText) console.log(this.$refs.mylogin.msg) this.$refs.mylogin.show() &#125; &#125;, components: &#123; login &#125;&#125;);]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（6）vue 动画&过渡]]></title>
    <url>%2F2019%2F01%2F31%2F%EF%BC%886%EF%BC%89vue-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[vue动画&amp;过渡1、使用过渡类名单元素/组件的过渡 使用 transition 元素，把 需要被动画控制的元素，包裹起来 自定义两组样式，来控制 transition 内部的元素实现动画 示例： 点击按钮，文字从右侧150px的位置向左侧移动出现，期间历时0.8s HTML结构： 123456789&lt;div id="app"&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;!-- 1. 使用 transition 元素，把 需要被动画控制的元素，包裹起来 --&gt; &lt;!-- transition 元素，是 Vue 官方提供的 --&gt; &lt;transition&gt; &lt;h3 v-if="flag"&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt;&lt;/div&gt; VM 实例： 12345678910&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; css样式： 1234567891011121314151617&lt;!-- 2. 自定义两组样式，来控制 transition 内部的元素实现动画 --&gt;&lt;style&gt; /* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 */ /* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了 */ .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; /* v-enter-active 【入场动画的时间段】 */ /* v-leave-active 【离场动画的时间段】 */ .v-enter-active, .v-leave-active&#123; transition: all 0.8s ease; &#125;&lt;/style&gt; 过渡的类名在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 自定义v-前缀​ 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v- 是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my-transition&quot;&gt;，那么 v-enter 会替换为 my-transition-enter。 v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线 示例： 在添加属性name=&quot;my&quot;，css样式中将v-换成my HTML结构 1234&lt;input type="button" value="toggle2" @click="flag2=!flag2"&gt;&lt;transition name="my"&gt; &lt;h6 v-if="flag2"&gt;这是一个H6&lt;/h6&gt;&lt;/transition&gt; CSS 12345678910.my-enter,.my-leave-to &#123; opacity: 0; transform: translateY(70px);&#125;.my-enter-active,.my-leave-active&#123; transition: all 0.8s ease;&#125; 2、使用第三方类库导入动画类库： 1&lt;link rel="stylesheet" href="./lib/animate.css"&gt; html结构有两种写法 第一种： 注意：enter-active-class和leave-active-class两个属性都要加上animated 1234567&lt;!-- 入场 bounceIn 离场 bounceOut --&gt;&lt;input type="button" value="toggle" @click="flag=!flag"&gt;&lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt;&lt;transition enter-active-class="animated bounceIn" leave-active-class="animated bounceOut"&gt; &lt;h3 v-if="flag"&gt;这是一个H3&lt;/h3&gt;&lt;/transition&gt; 第二种： 因为第一种办法设置属性比较麻烦，每个都要添加animated，所以第二种可以放到的class里面 1234567&lt;!-- 使用 :duration="&#123; enter: 200, leave: 400 &#125;" 来分别设置 入场的时长 和 离场的时长 --&gt;&lt;transition enter-active-class="bounceIn" leave-active-class="bounceOut" :duration="&#123; enter: 200, leave: 400 &#125;"&gt; &lt;h3 v-if="flag" class="animated"&gt;这是一个H3&lt;/h3&gt;&lt;/transition&gt; 3、钩子函数可以在属性中声明 JavaScript 钩子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter" v-on:enter-cancelled="enterCancelled" v-on:before-leave="beforeLeave" v-on:leave="leave" v-on:after-leave="afterLeave" v-on:leave-cancelled="leaveCancelled"&gt; &lt;!-- ... --&gt;&lt;/transition&gt;// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=&quot;false&quot;，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 示例： 定义 transition 组件以及三个钩子函数： 12345678&lt;input type="button" value="快到碗里来" @click="flag=!flag"&gt;&lt;!-- 1. 使用 transition 元素把 小球包裹起来 --&gt;&lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt; &lt;div class="ball" v-show="flag"&gt;&lt;/div&gt;&lt;/transition&gt; 定义方法： 12345678910111213141516171819202122232425methods: &#123; // 注意： 动画钩子函数的第一个参数：el，表示 要执行动画的那个DOM元素，是个原生的 JS DOM对象 // 大家可以认为 ， el 是通过 document.getElementById('') 方式获取到的原生JS DOM对象 beforeEnter(el)&#123; // beforeEnter 表示动画入场之前，此时，动画尚未开始，可以 在 beforeEnter 中，设置元素开始动画之前的起始样式 // 设置小球开始动画之前的，起始位置 el.style.transform = "translate(0, 0)" &#125;, enter(el, done)&#123; // 这句话，没有实际的作用，但是，如果不写，出不来动画效果； // 可以认为 el.offsetWidth 会强制动画刷新 el.offsetWidth // enter 表示动画 开始之后的样式，这里，可以设置小球完成动画之后的，结束状态 el.style.transform = "translate(150px, 450px)" el.style.transition = 'all 1s ease' // 这里的 done， 起始就是 afterEnter 这个函数，也就是说：done 是 afterEnter 函数的引用 done() &#125;, afterEnter(el)&#123; // 动画完成之后，会调用 afterEnter // console.log('ok') this.flag = !this.flag &#125;&#125; css样式： 123456.ball &#123; width: 15px; height: 15px; border-radius: 50%; background-color: red;&#125; 4、使用transition-group函数HTML结构 1234567891011121314151617181920212223242526272829&lt;div id="app"&gt;&lt;div&gt; &lt;label&gt; Id: &lt;input type="text" v-model="id"&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type="text" v-model="name"&gt; &lt;/label&gt; &lt;input type="button" value="添加" @click="add"&gt;&lt;/div&gt; &lt;!-- &lt;ul&gt; --&gt; &lt;!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup --&gt; &lt;!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 --&gt; &lt;!-- 给 ransition-group 添加 appear 属性，实现页面刚展示出来时候，入场时候的效果 --&gt; &lt;!-- 通过 为 transition-group 元素，设置 tag 属性，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认，渲染为 span 标签 --&gt; &lt;transition-group appear tag="ul"&gt; &lt;li v-for="(item, i) in list" :key="item.id" @click="del(i)"&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;!-- &lt;/ul&gt; --&gt;&lt;/div&gt; vm结构 1234567891011121314151617181920212223// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', list: [ &#123; id: 1, name: '赵高' &#125;, &#123; id: 2, name: '秦桧' &#125;, &#123; id: 3, name: '严嵩' &#125;, &#123; id: 4, name: '魏忠贤' &#125; ] &#125;, methods: &#123; add() &#123; this.list.push(&#123; id: this.id, name: this.name &#125;) this.id = this.name = '' &#125;, del(i) &#123; this.list.splice(i, 1) &#125; &#125;&#125;); css结构 12345678910111213141516171819202122232425262728293031323334li &#123; border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%;&#125;li:hover &#123; background-color: hotpink; transition: all 0.8s ease;&#125;.v-enter,.v-leave-to &#123; opacity: 0; transform: translateY(80px);&#125;.v-enter-active,.v-leave-active &#123; transition: all 0.6s ease;&#125;/* 下面的 .v-move 和 .v-leave-active 配合使用，能够实现列表后续的元素，渐渐地漂上来的效果 */.v-move &#123; transition: all 0.6s ease;&#125;.v-leave-active&#123; position: absolute;&#125;]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github pages-hexo-next 博客搭建]]></title>
    <url>%2F2019%2F01%2F21%2Fgithub-pages-hexo-next-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[博客搭建记录成功搭建了这个博客在GitHub上，主要记录一下为了以后使用方便。 主要的资源： 本博客使用的是hexo博客框架，官网在这官网 GitHub在这GitHub 主题next的论坛，这里 hexo插件，这里 搭建博客主要借鉴的文章是有： 知乎的一篇文章这是一片关于GitHub和hexo的文章，讲的很好，非常适合入门。 一位小姐姐的博客对于博客文章的内容讲的非常详细，而且最重要的就是她汇总了网上所有大神的文章链接，也包括上面的那篇。我觉得跟着这个博客的文章做，就可以了。超级推荐，一定要看！！！ 这是一篇很详细的hexo-next主题设置基本上把设置的内容都介绍了，跟着操作就好了。 七牛云作为图床的使用七牛云作为图床开始试了很多的方法，只有这个简单但是管用。 一位大神的博客对hexo有好多独有但是很有意思的设置，当你把前面的都做完或者试过了后，可以看看他的，有好多好玩的东西。 下面就是记录一下搭建博客的主要内容摘抄，注意以下内容均来自以上的博客，如果想要详细了解可以去看上面的大神博客。 博客知识简介博客生成器目前主流的两种建站的方式： Wordpress GitHub Pages+Hexo 我使用的就是第二种，主要就是简单，但是有很好的成就感。。。 第一种Wordpress属于动态博客生成器，其中的代表还有FarBox、Ghost等， 第二种hexo属于静态博客生成器，其中的代表还有Jekyll、Octopress、Hugo等。 关于动态和静态的区别主要有以下几点: 资源占用上，静态的相比动态占用服务器资源少，还可以托管在Github Pages上； 发布更新操作上，由于静态博客没有管理后台，所以发布更新内容要比动态博客繁琐； 访问速度上，由于静态博客没有数据库，所以访问速度更快； 安全性上，静态博客相比动态博客免疫了很多Web攻击套路； web服务器简单来说就是网站的部署位置，一般可以找国内的服务器提供商，如阿里云、腾讯云、七牛云等。也可以用免费的GitHub pages。一般个人博客使用GitHub pages就够用了。 图床服务器上面的服务器用于存放网页，属于Web服务器，而图床是用于提供多媒体资源（图片、视频）存储的服务器，把网页和多媒体资源分开存储是有好处的，如果把图片都放Web服务器上，Web服务器的访问带宽会一下子就被占完，这样访问网站的体验会极差。我使用的是七牛图床，免费的而且非常好。这是一个关于七牛云作为图床的介绍 域名和备案光有服务器还不够，此时你把网页部署上服务器后，只能通过服务器绑定的IP地址访问到你的站点。而这种对外开放的站点，基本没有使用IP来让人访问的，因为非常不方便记忆，所以，你需要购买一个域名。域名购买渠道很多，下面是三个我比较了解的渠道： Godaddy：https://www.godaddy.com/ ，老牌厂商。 阿里云：https://wanwang.aliyun.com/domain/ ，原中国万网，被阿里收购合并到阿里云。 DNSPod：https://domains.dnspod.cn/ ，被腾讯收购。 DNS解析有了域名，等部署完服务器后，还要设置对应DNS解析，目的是为了告诉所有访问这个域名的浏览器，应该访问哪个IP地址的主机。关于DNS解析服务，这里推荐知名的老牌厂商DNSPod，服务不错，也有免费套餐。这些在阿里云上都有相应的教程，按照教程操作就可以了。 搭建过程搭建步骤一般来说，搭建博客有以下几个步骤： 获得个人网站域名 GitHub创建个人仓库 安装Git 安装Node.js 安装Hexo 推送网站 绑定域名 更换主题 初识MarkDown语法 发布文章 寻找图床 个性化设置 其他 附录 以上绝大部分都是那种用一次就行的，看大神们的博客就可以了。这里我只是摘要hexo的一些重要的命令 hexo的一些重要的命令npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客 命令简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 如果是修改完本地的博客，想要预览效果的话，可以输入下面的三个命令（命令界面需要进入到博客的文件夹，按shift右击，选择在此处打开powershell窗口，就是npm的命令界面窗口） 123hexo clean hexo g hexo s 以上命令成功后，在浏览器输入： http://localhost:4000，就可以看到新的预览界面 如果本地预览完成了，想要推送 123hexo clean hexo g hexo d 以上命令成功后，就可以输入自己的GitHub网页的个人博客进行访问。 以上的命令需要了解就行，后面个性化的时候，可以把三个命令绑定为一个命令，更为快速。 个性化讲道理，个性化才是搭建博客真正的乐趣所在，感觉就像小时候照着图纸拼四驱车一样，但是又比拼四驱车要好，这个做坏了可以回退版本，四驱车就废了!ヽ(￣▽￣)ﾉ 我使用的主题是next，为什么？因为大家都在用，教程多，不会还可以查啊。。。 以下就摘一些我觉得重要 添加菜单进入theme目录，编辑_config_yml文件，找到menu:字段，在该字段下添加一个字段。 1234menu: home: / about: /about ...... 然后找到lanhuages目录，编辑zh-Hans.yml文件： 1234menu: home: 首页 about: 关于作者 ...... 更新页面显示的中文字符，最后进入theme目录下的Source目录，新增一个about目录，里面写一个index.html文件。 自定义hexo new生成md文件的选项在/scaffolds/post.md文件中添加： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truepermalink: 01top: 0password:--- 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如: 12345---......copyright: truetop: 100--- 默认不设置则为0，数值相同时按时间排序。 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: 12&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 添加自动部署命令在package.json里面添加如下命令： 1234&quot;scripts&quot;: &#123;&quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d&quot;,&quot;test&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo s&quot;&#125;, 然后运行npm run build，我们就会自动删除老文件，生成新文件，压缩html、css然后发布到github或其他静态服务器资源。但是不能成功推送，不知道是为什么？？？ 然后运行npm run test，我们就会自动删除老文件，生成新文件，压缩html、css然后发布到本地服务器做预览。 最后end写这个文章就是记录分享，大家借鉴就好，主要也是做个记录，毕竟不能白搞了这么长的时间。 对了，关于markdown我用的是typora，感觉挺好的，可以直接用效果去写，连那些markdown的格式都可以忽略了。]]></content>
      <categories>
        <category>学习小记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>学习小记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（4）vue生命周期]]></title>
    <url>%2F2019%2F01%2F18%2F%EF%BC%884%EF%BC%89vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="修改msg" @click="msg='No'"&gt; &lt;h3 id="h3"&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'ok' &#125;, methods: &#123; show() &#123; console.log('执行了show方法') &#125; &#125;, beforeCreate() &#123; // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它 // console.log(this.msg) // this.show() // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 &#125;, created() &#123; // 这是遇到的第二个生命周期函数 // console.log(this.msg) // this.show() // 在 created 中，data 和 methods 都已经被初始化好了！ // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作 &#125;, beforeMount() &#123; // 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中 // console.log(document.getElementById('h3').innerText) // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 &#125;, mounted() &#123; // 这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 // console.log(document.getElementById('h3').innerText) // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 &#125;, // 接下来的是运行中的两个事件 beforeUpdate() &#123; // 这时候，表示 我们的界面还没有被更新【数据被更新了吗？ 数据肯定被更新了】 /* console.log('界面上元素的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) */ // 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步 &#125;, updated() &#123; console.log('界面上元素的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) // updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2019%2F01%2F16%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex 为什么要使用概念vuex 是 Vue 配套的 公共数据管理工具，它可以把一些共享的数据，保存到 vuex 中，方便 整个程序中的任何组件直接获取或修改我们的公共数据； Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 vuex安装首先在webpack创建的vue-cli工程下，通过npm命令行，安装vuex 1npm install vuex --save 然后 , 在 main.js 中导入包 : 1234567import vuex from 'vuex'Vue.use(vuex);var store = new vuex.Store(&#123;//store对象 state:&#123; show:false &#125;&#125;) 再然后 , 在实例化 Vue对象时加入 store 对象 : 1234567new Vue(&#123; el: '#app', router, store, //将vuex创建的store挂载到VM实例上，只要挂载到VM上，就可以任何组件使用store来存取数据 template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 完成上述的步骤，vue中类似于$store.state.show 的操作就可以使用了 vuex核心概念store什么是store每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 创建store官网上和教程上给的都是在main.js上，也可以创建store.js把下面的代码写在store.js里面，在main.js里面引用store.js（后面给出了具体的操作） 12345678910111213141516// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; //把state想象成组件中的data，专门用来存储数据的 count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;)//这里的state就相当于data//这里的mutations就相当于methods 前面为了方便 , 我们把 store 对象写在了 main.js 里面 , 但实际上为了便于日后的维护 , 我们分开写更好 , 我们在 src 目录下 , 新建一个 store 文件夹 , 然后在里面新建一个 index.js : 123456789import Vue from 'vue'import vuex from 'vuex'Vue.use(vuex);export default new vuex.Store(&#123; state:&#123; show:false &#125;&#125;) 那么相应的 , 在 main.js 里的代码应该改成 : 12345678910//vueximport store from './store'new Vue(&#123; el: '#app', router, store,//使用store template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 这样就把 store 分离出去了 , 那么还有一个问题是 : 这里 $store.state.show 无论哪个组件都可以使用 , 那组件多了之后 , 状态也多了 , 这么多状态都堆在 store 文件夹下的 index.js 不好维护怎么办 ? 我们可以使用 vuex 的 modules , 把 store 文件夹下的 index.js 改成 : 1234567891011import Vue from 'vue'import vuex from 'vuex'Vue.use(vuex);import dialog_store from '../components/dialog_store.js';//引入某个store对象export default new vuex.Store(&#123; modules: &#123; dialog: dialog_store &#125;&#125;) 这里我们引用了一个 dialog_store.js , 在这个 js 文件里我们就可以单独写 dialog 组件的状态了 : 12345export default &#123; state:&#123; show:false &#125;&#125; 做出这样的修改之后 , 我们将之前我们使用的 $store.state.show 统统改为 $store.state.dialog.show 即可。 如果还有其他的组件需要使用 vuex , 就新建一个对应的状态文件 , 然后将他们加入 store 文件夹下的 index.js 文件中的 modules 中。 1234modules: &#123; dialog: dialog_store, other: other,//其他组件&#125; mutations访问store中的数据如果在组件中想要访问store中的数据，只能通过this.$store.state.***来访问 修改store中的数据1this.$store.state.count++; //千万不要这么做，这不符合vuex的设计理念 注意，如果要操作store中的state值，只能通过调用mutations提供的方法，才能操作对应的数据，不推荐直接操作state中的数据。因为，万一数据出现了紊乱，不能快速定位到错误的原因。因为每个组件都有操作数据的方法。 如果组件要调用mutations中的方法，只能使用this.$store.commit(&#39;方法名&#39;)。 mutations方法的提交参数1234567891011121314const store = new Vuex.Store(&#123; state: &#123; //把state想象成组件中的data，专门用来存储数据的 count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125;, substract(state,c)&#123; &#125; &#125;&#125;) 12345678910111213&lt;script&gt;export default&#123;data()&#123;&#125;,methods:&#123; remove()&#123; //vue组件中调用mutations中的方法 this.$store.commit("substract",3); &#125;&#125;&#125;&lt;/script&gt; mutations的函数参数列表中，最多支持两个参数，其中，参数1：是state状态；参数2：通过commit提交的参数 getters包装数据12345678910111213141516171819const store = new Vuex.Store(&#123; state: &#123; //把state想象成组件中的data，专门用来存储数据的 count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125;, substract(state,c)&#123; //方法内容 &#125; getters()&#123; optCount: function(state)&#123; return '当前最新的count值是：' + state.count &#125; &#125; &#125;&#125;) 注意：这里的getters，只负责对外提供数据，不负责修改数据，如果想要修改state中的数据，应该去找mutations中的方法 getters中的方法和过滤器中额方法类似，因为过滤器和getters都没有修改数据，只是把原数据做了一层包装，提供给了调用者。 其次，getters也和computed比较像，只要state中的数据发生了变化，那么如果getters正好也引用了这个数据，那么，就会立刻触发getters的重新求值。 actions多个 state 的操作 , 使用 mutations 会来触发会比较好维护 , 那么需要执行多个 mutations 就需要用 action 了: 1234567891011121314151617export default &#123; state:&#123;//state show:false &#125;, mutations:&#123; switch_dialog(state)&#123;//这里的state对应着上面这个state state.show = state.show?false:true; //你还可以在这里执行其他的操作改变state &#125; &#125;, actions:&#123; switch_dialog(context)&#123;//这里的context和我们使用的$store拥有相同的对象和方法 context.commit('switch_dialog'); //你还可以在这里触发其他的mutations方法 &#125;, &#125;&#125; 那么 , 在之前的父组件中 , 我们需要做修改 , 来触发 action 里的 switch_dialog 方法: 123456789101112131415&lt;template&gt; &lt;div id="app"&gt; &lt;a href="javascript:;" @click="$store.dispatch('switch_dialog')"&gt;点击&lt;/a&gt; &lt;t-dialog&gt;&lt;/t-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import dialog from './components/dialog.vue'export default &#123; components:&#123; "t-dialog":dialog &#125;&#125;&lt;/script&gt; 使用 $store.dispatch(&#39;switch_dialog&#39;) 来触发 action 中的 switch_dialog 方法。 官方推荐 , 将异步操作放在 action 中。 mapState、mapGetters、mapActions(未看)很多时候 , $store.state.dialog.show 、$store.dispatch(&#39;switch_dialog&#39;) 这种写法又长又臭 , 很不方便 , 我们没使用 vuex 的时候 , 获取一个状态只需要 this.show , 执行一个方法只需要 this.switch_dialog 就行了 , 使用 vuex 使写法变复杂了 ? 使用 mapState、mapGetters、mapActions 就不会这么复杂了。 以 mapState 为例 : 12345678910111213141516&lt;template&gt; &lt;el-dialog :visible.sync="show"&gt;&lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex';export default &#123; computed:&#123; //这里的三点叫做 : 扩展运算符 ...mapState(&#123; show:state=&gt;state.dialog.show &#125;), &#125;&#125;&lt;/script&gt; 相当于 : 1234567891011121314&lt;template&gt; &lt;el-dialog :visible.sync="show"&gt;&lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex';export default &#123; computed:&#123; show()&#123; return this.$store.state.dialog.show; &#125; &#125;&#125;&lt;/script&gt; mapGetters、mapActions 和 mapState 类似 , mapGetters 一般也写在 computed 中 , mapActions 一般写在 methods中。]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目 element国际化]]></title>
    <url>%2F2019%2F01%2F16%2Fvue%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[vue项目 element国际化说明Element组件自身提供国际化，支持多种语言，可以在src/main.js添加如下代码，来令Element的组件使用指定语言。 123import ElementUI from 'element-ui'import locale from 'element-ui/lib/locale/lang/en'Vue.use(ElementUI, &#123; locale &#125;) 但上方代码只会令Element的组件使用指定语言，并不会让我们自己写的代码能支持国际化，因此我们要加入自己的i18n。 另外以上是使用指定的其他一种语言，为了能够切换多种语言，我们要导入多种语言。 实现以下以实现中文和英文切换为例： 安装vue-i18n： 1npm install vue-i18n --save 创建本系统的中文语言文件src/assets/lang/zh-cn.js 1234567891011export default &#123; common: &#123; ok: '确认', cancel: '取消' &#125;, login: &#123; login: '登录', register: '注册', ... &#125;&#125; 创建本系统的英文语言文件src/assets/lang/en.js 1234567891011export default &#123; common: &#123; ok: 'OK', cancel: 'Cancle' &#125;, login: &#123; login: 'Login', register: 'Register', ... &#125;&#125; 修改src/main.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router/index'import Mock from './mock/index'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import 'font-awesome/scss/font-awesome.scss'import VueScroll from 'vuescroll'import 'vuescroll/dist/vuescroll.css'import './assets/css/common.scss'/* 1. 导入国际化相关依赖 */import VueI18n from 'vue-i18n'import myEnLocale from './assets/lang/en'import myZhLocale from './assets/lang/zh-cn'import enLocale from 'element-ui/lib/locale/lang/en'import zhLocale from 'element-ui/lib/locale/lang/zh-CN'Vue.config.productionTip = false/* mockjs */Mock.mockData()/* vue-i18n */Vue.use(VueI18n)// 2.1 支持两种语言，每种语言需要合并自己书写的语言文件和element-ui的同语言文件const messages = &#123; 'en': Object.assign(myEnLocale, enLocale), 'zh-cn': Object.assign(myZhLocale, zhLocale)&#125;// 2.2 加载用户语言设置，你也可以把此值存放在后台const lang = localStorage.getItem('user-language') || 'zh-cn'// 2. 实例化VueI18nconst i18n = new VueI18n(&#123; locale: lang, // 2.2 messages // 2.1&#125;)/* element-ui */Vue.use(ElementUI, &#123; // 3. element-ui默认支持vue-i18n@5.x版本，6.x以上的版本需要添加此配置项，当前已8.x i18n: (key, value) =&gt; i18n.t(key, value)&#125;)/* vuescroll */Vue.use(VueScroll, &#123;ops: &#123;bar: &#123;background: '#C0C4CC'&#125;&#125;&#125;)/* eslint-disable no-new */new Vue(&#123; el: '#app', router, i18n, // 4. 将i18n挂载到根实例 components: &#123;App&#125;, template: '&lt;App/&gt;'&#125;) 使用：以下代码举例了在vue组件中如何使用语言文件配置的值 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;!-- 1. 属性中使用，记得使用v-bind，即不要遗漏前面的冒号 --&gt; &lt;input :placeholder="$t('login.login')"/&gt; &lt;!-- 2. HTML中使用 --&gt; &lt;button&gt;&#123;&#123; $t("common.ok") &#125;&#125;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; // 3. js中使用 const cancel = this.$t('common.cancel') &#125;&#125;&lt;/script&gt; 代码里举了三个例子，分别是v-bind绑定的、HTML里直接使用的和js中使用的，直接用this引用 切换语言：记录并切换语言 12localStorage.setItem('user-language', 'zh-cn')this.$i18n.locale = 'zh-cn' 项目实现的具体代码TheLayoutHeader.vuetemplate部分12345678910111213141516&lt;div class="navbar-text" @click="clickLangue"&gt; &lt;el-dropdown trigger="click" @command="changeLanguage" id="langDropDown" size="medium"&gt; &lt;p class="user-info" style="height: 10px"&gt; &#123;&#123; $t('header.languageSelect') &#125;&#125; &lt;i class="el-icon-arrow-down el-icon--right drop-icon" id="langDropIcon"&gt;&lt;/i&gt; &lt;/p&gt; &lt;el-dropdown-menu slot="dropdown"&gt; &lt;el-dropdown-item command="zh-cn" :disabled="this.lang==='zh-cn'"&gt; &#123;&#123;$t('header.langZh')&#125;&#125; &lt;/el-dropdown-item&gt; &lt;el-dropdown-item command="en" :disabled="this.lang==='en'"&gt; &#123;&#123;$t('header.langEn')&#125;&#125; &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt;&lt;/div&gt; 使用了element的下拉菜单，显示菜单的名称已经实现国际化。 script部分1234567891011121314151617//改变语言 changeLanguage (language) &#123; localStorage.setItem('user-language', language) this.$i18n.locale = language this.lang = language this.timeFormate(new Date()) &#125;,// clickLangue () &#123; let langDropIcon = document.getElementById('langDropIcon') if (this.langDrop) &#123; langDropIcon.style.transform = 'rotate(0deg)' &#125; else &#123; langDropIcon.style.transform = 'rotate(-180deg)' &#125; this.langDrop = !this.langDrop &#125;, 建立文字国际化库在./src/assets/lang/en.js 1234567891011121314151617181920212223242526272829export default &#123; common: &#123; ok: 'OK', cancel: 'Cancel' &#125;, login: &#123; login: 'Login', register: 'Register', account: 'Account', password: 'Password', showPass: 'show password', forgetPass: 'forget password?', modifyPass: 'Change password', oldPass: 'Old Password', newPass: 'New Password', checkPass: 'Repeat password', inputAccount: 'Please input account', inputPass: 'Please input password', inputOldPass: 'Please input old password', inputNewPass: 'Please input new password', inputCheckPass: 'Please input password again', errorCheckPass: 'Password not the same!', loginSuccess: 'Login Success!', registerSuccess: 'Register Success!', changePassMessage: 'Change password?', tip: 'Tip', changeSuccess: 'Change Success', cancel: 'Cancel!' &#125;, 在./src/assets/lang/zh-cn.js 1234567891011121314151617181920212223242526272829export default &#123; common: &#123; ok: '确认', cancel: '取消' &#125;, login: &#123; login: '登录', register: '注册', account: '账号', password: '密码', showPass: '显示密码', forgetPass: '忘记密码？', modifyPass: '修改密码', oldPass: '旧密码', newPass: '新密码', checkPass: '重复密码', inputAccount: '请输入账号', inputPass: '请输入密码', inputOldPass: '请输入旧密码', inputNewPass: '请输入新密码', inputCheckPass: '请再次输入密码', errorCheckPass: '两次输入密码不一致!', loginSuccess: '登录成功！', registerSuccess: '注册成功！', changePassMessage: '确认修改密码吗？', tip: '提示', changeSuccess: '修改成功', cancel: '已取消！' &#125;, 自己建立自己的文本库，如果觉得可以是共用的可以放到common里面，最好一个vue组件就建立一个 例如： TheLayoutHeader.vue 1234567891011121314151617181920212223TheLayoutHeader:&#123; lock:'锁定', unlock:'解锁', logout:'退出', year:'年', month:'月', day:'日', configurationManagement:'配置管理', basicConfigurationManagement:'基础配置管理', locationConfigurationManagement:'机房配置管理', cabinetConfigurationManagement:'机架配置管理', deviceCreatPort:'业务端口配置管理', topologyManagement:'拓扑管理', subnetConfigurationManagement:'子网配置管理', linkConfigurationManagement:'链路配置管理', deviceConfigurationManagement:'网元配置管理', controlManagement:'控制管理', businessManagement:'业务管理', alarmManagement:'故障管理', performanceManagement:'性能管理', safeManagemnet:'安全管理',&#125;, 12345678910111213141516171819202122TheLayoutHeader:&#123; lock:'lock', unlock:'unlock', logout:'logout', year:'.', month:'.', day:'', configurationManagement:'configurationManagement', basicConfigurationManagement:'basicConfigurationManagement', locationConfigurationManagement:'locationConfigurationManagement', cabinetConfigurationManagement:'cabinetConfigurationManagement', deviceCreatPort:'deviceCreatPort', topologyManagement:'topologyManagement', subnetConfigurationManagement:'subnetConfigurationManagement', linkConfigurationManagement:'linkConfigurationManagement', deviceConfigurationManagement:'deviceConfigurationManagement', controlManagement:'controlManagement', businessManagement:'businessManagement', alarmManagement:'alarmManagement', performanceManagement:'performanceManagement', safeManagemnet:'safeManagemnet',&#125;,]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（5）vue-resource]]></title>
    <url>%2F2019%2F01%2F15%2F%EF%BC%885%EF%BC%89vue-resourse%2F</url>
    <content type="text"><![CDATA[vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子； vue-resource 的配置步骤 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求12345678getInfo() &#123; // get 方式获取数据 // 当发起get请求之后， 通过 .then 来设置成功的回调函数 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; &#123; // 通过 result.body 拿到服务器返回的成功的数据 // console.log(result.body) console.log(res.body); &#125;)&#125; 发送post请求123456789101112postInfo() &#123; var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded // 手动发起的 Post 请求，默认没有表单格式，所以，有的服务器处理不了 // 通过 post 方法的第三个参数， &#123; emulateJSON: true &#125; 设置 提交的内容类型 为 普通表单数据格式 this.$http.post(url, &#123; name: 'zs' &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送JSONP请求获取数据123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 案例展示（品牌列表）1、完成获取功能1234567891011121314151617181920getAllList() &#123; // 获取所有的品牌列表 // 分析： // 1. 由于已经导入了 Vue-resource这个包，所以 ，可以直接通过 this.$http 来发起数据请求 // 2. 根据接口API文档，知道，获取列表的时候，应该发起一个 get 请求 // 3. this.$http.get('url').then(function(result)&#123;&#125;) // 4. 当通过 then 指定回调函数之后，在回调函数中，可以拿到数据服务器返回的 result // 5. 先判断 result.status 是否等于0，如果等于0，就成功了，可以 把 result.message 赋值给 this.list ; 如果不等于0，可以弹框提醒，获取数据失败！ this.$http.get('api/getprodlist').then(result =&gt; &#123; // 注意： 通过 $http 获取到的数据，都在 result.body 中放着 var result = result.body if (result.status === 0) &#123; // 成功了 this.list = result.message &#125; else &#123; // 失败了 alert('获取数据失败！') &#125; &#125;)&#125; 2、完成添加功能1234567891011121314151617181920212223242526272829303132333435add() &#123; // 添加品牌列表到后台服务器 // 分析： // 1. 听过查看 数据API接口，发现，要发送一个 Post 请求， this.$http.post // 2. this.$http.post() 中接收三个参数： // 2.1 第一个参数： 要请求的URL地址 // 2.2 第二个参数： 要提交给服务器的数据 ，要以对象形式提交给服务器 &#123; name: this.name &#125; // 3.3 第三个参数： 是一个配置对象，要以哪种表单数据类型提交过去， &#123; emulateJSON: true &#125;, 以普通表单格式，将数据提交给服务器 application/x-www-form-urlencoded // 3. 在 post 方法中，使用 .then 来设置成功的回调函数，如果想要拿到成功的结果，需要 result.body /* this.$http.post('api/addproduct', &#123; name: this.name &#125;, &#123; emulateJSON: true &#125;).then(result =&gt; &#123; if (result.body.status === 0) &#123; // 成功了！ // 添加完成后，只需要手动，再调用一下 getAllList 就能刷新品牌列表了 this.getAllList() // 清空 name this.name = '' &#125; else &#123; // 失败了 alert('添加失败！') &#125; &#125;) */ this.$http.post('api/addproduct', &#123; name: this.name &#125;).then(result =&gt; &#123; if (result.body.status === 0) &#123; // 成功了！ // 添加完成后，只需要手动，再调用一下 getAllList 就能刷新品牌列表了 this.getAllList() // 清空 name this.name = '' &#125; else &#123; // 失败了 alert('添加失败！') &#125; &#125;)&#125;, 3、删除功能12345678910del(id) &#123; // 删除品牌 this.$http.get('api/delproduct/' + id).then(result =&gt; &#123; if (result.body.status === 0) &#123; // 删除成功 this.getAllList() &#125; else &#123; alert('删除失败！') &#125; &#125;)&#125; 4、全局配置配置数据接口的根域名使用全局配置，这样就可以免去开头的IP了 在代码块的开头中，添加改段代码 12// 如果我们通过全局配置了，请求的数据接口 根域名，则 ，在每次单独发起 http 请求的时候，请求的 url 路径，应该以相对路径开头，前面不能带 / ，否则 不会启用根路径做拼接；Vue.http.options.root = 'http://vue.studyit.io/'; get函数里面添加该不包含前面IP的url，注意开头不应包含“/” 1this.$http.get('api/getprodlist').then(result =&gt; &#123; emulateJSON选项在代码块的开头中，添加改段代码 12// 全局启用 emulateJSON 选项Vue.http.options.emulateJSON = true; 全局启用就不用加{ emulateJSON: true } 1234/*这是没有全局启用*/this.$http.post('api/addproduct', &#123; name: this.name &#125;, &#123; emulateJSON: true &#125;).then(result =&gt; &#123;/*这是启用全局*/this.$http.post('api/addproduct', &#123; name: this.name &#125;).then(result =&gt; &#123;]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（3）vue自定义按键、指令]]></title>
    <url>%2F2019%2F01%2F15%2F%EF%BC%883%EF%BC%89vue%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%94%AE%E3%80%81%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[vue自定义按键vue自定义按键1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./lib/bootstrap-3.3.7.css"&gt; &lt;!-- 需要用到Jquery吗？？？ --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &#123;&#123;1+1&#125;&#125; --&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body form-inline"&gt; &lt;label&gt; Name: //按enter实现 &lt;input type="text" class="form-control" v-model="name" @keyup.enter="add"&gt; //113是F2的码，所以按F2实现 &lt;input type="text" class="form-control" v-model="name" @keyup.113="add"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义全局指令——让文本框获取焦点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./lib/bootstrap-3.3.7.css"&gt; &lt;!-- 需要用到Jquery吗？？？ --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &#123;&#123;1+1&#125;&#125; --&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body form-inline"&gt; &lt;label&gt; 搜索名称关键字： &lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 --&gt; &lt;input type="text" class="form-control" v-model="keywords" id="search" v-focus v-color="'green'"&gt; &lt;/label&gt; &lt;/div&gt; &lt;script&gt; // 使用 Vue.directive() 定义全局的指令 v-focus // 其中：参数1 ： 指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀, // 但是： 在调用的时候，必须 在指令名称前 加上 v- 前缀来进行调用 // 参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive('focus', &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 // 注意： 在每个 函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用钩子函数的第二个binding获得参数值在html中的输入框中，设置v-color 在script中，自定义的bind函数的第二个参数binding获取值“green” 12345&lt;label&gt; 搜索名称关键字： &lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 --&gt; &lt;input type="text" class="form-control" v-model="keywords" id="search" v-focus v-color="'green'"&gt;&lt;/label&gt; 1234567891011121314151617&lt;script&gt; // 自定义一个 设置字体颜色的 指令 Vue.directive('color', &#123; // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 bind: function (el, binding) &#123; // el.style.color = 'red' // console.log(binding.name) // 和样式相关的操作，一般都可以在 bind 执行 // console.log(binding.value) // console.log(binding.expression) el.style.color = binding.value &#125; &#125;)&lt;/script&gt; 定义私有指令123&lt;div id="app2"&gt; &lt;h3 v-color="'pink'" v-fontweight="900" v-fontsize="50"&gt;&#123;&#123; dt | dateFormat &#125;&#125;&lt;/h3&gt; &lt;/div&gt; 123456789101112131415161718&lt;script&gt;// 如何自定义一个私有的过滤器（局部） var vm2 = new Vue(&#123; el: '#app2', data: &#123; dt: new Date() &#125;, methods: &#123;&#125;, filters: &#123;&#125;, directives: &#123; // 自定义私有指令 'fontweight': &#123; // 设置字体粗细的 bind: function (el, binding) &#123; el.style.fontWeight = binding.value &#125; &#125; &#125; &#125;)&lt;/script&gt; 指令的简写方式123&lt;div id="app2"&gt; &lt;h3 v-color="'pink'" v-fontweight="900" v-fontsize="50"&gt;&#123;&#123; dt | dateFormat &#125;&#125;&lt;/h3&gt; &lt;/div&gt; 12345678910111213141516&lt;script&gt;// 如何自定义一个私有的过滤器（局部） var vm2 = new Vue(&#123; el: '#app2', data: &#123; dt: new Date() &#125;, methods: &#123;&#125;, filters: &#123;&#125;, directives: &#123; // 自定义私有指令 'fontsize': function (el, binding) &#123; // 注意：这个 function 等同于 把 代码写到了 bind 和 update 中去 el.style.fontSize = parseInt(binding.value) + 'px' &#125; &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（2）vue过滤器]]></title>
    <url>%2F2019%2F01%2F14%2F%EF%BC%882%EF%BC%89vue%20%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[品牌列表案例源码，这里面用到了这次学习的所有内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./lib/bootstrap-3.3.7.css"&gt; &lt;!-- 需要用到Jquery吗？？？ --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &#123;&#123;1+1&#125;&#125; --&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body form-inline"&gt; &lt;label&gt; Id: &lt;input type="text" class="form-control" v-model="id"&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type="text" class="form-control" v-model="name" @keyup.f2="add"&gt; &lt;/label&gt; &lt;!-- 在Vue中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了 --&gt; &lt;input type="button" value="添加" class="btn btn-primary" @click="add()"&gt; &lt;label&gt; 搜索名称关键字： &lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 --&gt; &lt;input type="text" class="form-control" v-model="keywords" id="search" v-focus v-color="'green'"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class="table table-bordered table-hover table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 之前， v-for 中的数据，都是直接从 data 上的list中直接渲染过来的 --&gt; &lt;!-- 现在， 我们自定义了一个 search 方法，同时，把 所有的关键字，通过传参的形式，传递给了 search 方法 --&gt; &lt;!-- 在 search 方法内部，通过 执行 for 循环， 把所有符合 搜索关键字的数据，保存到 一个新数组中，返回 --&gt; &lt;tr v-for="item in search(keywords)" :key="item.id"&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td v-text="item.name"&gt;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.ctime | dateFormat() &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id="app2"&gt; &lt;h3 v-color="'pink'" v-fontweight="900" v-fontsize="50"&gt;&#123;&#123; dt | dateFormat &#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 全局的过滤器， 进行时间的格式化 // 所谓的全局过滤器，就是所有的VM实例都共享的 Vue.filter('dateFormat', function (dateStr, pattern = "") &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() // return y + '-' + m + '-' + d if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125;) // 自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113 // 使用 Vue.directive() 定义全局的指令 v-focus // 其中：参数1 ： 指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀, // 但是： 在调用的时候，必须 在指令名称前 加上 v- 前缀来进行调用 // 参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive('focus', &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 // 注意： 在每个 函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125; &#125;) // 自定义一个 设置字体颜色的 指令 Vue.directive('color', &#123; // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 bind: function (el, binding) &#123; // el.style.color = 'red' // console.log(binding.name) // 和样式相关的操作，一般都可以在 bind 执行 // console.log(binding.value) // console.log(binding.expression) el.style.color = binding.value &#125; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', keywords: '', // 搜索的关键字 list: [ &#123; id: 1, name: '奔驰', ctime: new Date() &#125;, &#123; id: 2, name: '宝马', ctime: new Date() &#125; ] &#125;, methods: &#123; add() &#123; // 添加的方法 // console.log('ok') // 分析： // 1. 获取到 id 和 name ,直接从 data 上面获取 // 2. 组织出一个对象 // 3. 把这个对象，调用 数组的 相关方法，添加到 当前 data 上的 list 中 // 4. 注意：在Vue中，已经实现了数据的双向绑定，每当我们修改了 data 中的数据，Vue会默认监听到数据的改动，自动把最新的数据，应用到页面上； // 5. 当我们意识到上面的第四步的时候，就证明大家已经入门Vue了，我们更多的是在进行 VM中 Model 数据的操作，同时，在操作Model数据的时候，指定的业务逻辑操作； var car = &#123; id: this.id, name: this.name, ctime: new Date() &#125; this.list.push(car) this.id = this.name = '' &#125;, del(id) &#123; // 根据Id删除数据 // 分析： // 1. 如何根据Id，找到要删除这一项的索引 // 2. 如果找到索引了，直接调用 数组的 splice 方法 /* this.list.some((item, i) =&gt; &#123; if (item.id == id) &#123; this.list.splice(i, 1) // 在 数组的 some 方法中，如果 return true，就会立即终止这个数组的后续循环 return true; &#125; &#125;) */ var index = this.list.findIndex(item =&gt; &#123; if (item.id == id) &#123; return true; &#125; &#125;) // console.log(index) this.list.splice(index, 1) &#125;, search(keywords) &#123; // 根据关键字，进行数据的搜索 /* var newList = [] this.list.forEach(item =&gt; &#123; if (item.name.indexOf(keywords) != -1) &#123; newList.push(item) &#125; &#125;) return newList */ // 注意： forEach some filter findIndex 这些都属于数组的新方法， // 都会对数组中的每一项，进行遍历，执行相关的操作； return this.list.filter(item =&gt; &#123; // if(item.name.indexOf(keywords) != -1) // 注意 ： ES6中，为字符串提供了一个新方法，叫做 String.prototype.includes('要包含的字符串') // 如果包含，则返回 true ，否则返回 false // contain if (item.name.includes(keywords)) &#123; return item &#125; &#125;) // return newList &#125; &#125; &#125;); // 如何自定义一个私有的过滤器（局部） var vm2 = new Vue(&#123; el: '#app2', data: &#123; dt: new Date() &#125;, methods: &#123;&#125;, filters: &#123; // 定义私有过滤器 过滤器有两个 条件 【过滤器名称 和 处理函数】 // 过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了，这时候 优先调用私有过滤器 dateFormat: function (dateStr, pattern = '') &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = (dt.getMonth() + 1).toString().padStart(2, '0') var d = dt.getDate().toString().padStart(2, '0') if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours().toString().padStart(2, '0') var mm = dt.getMinutes().toString().padStart(2, '0') var ss = dt.getSeconds().toString().padStart(2, '0') return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125; ~~~~~~~` &#125; &#125; &#125;, directives: &#123; // 自定义私有指令 'fontweight': &#123; // 设置字体粗细的 bind: function (el, binding) &#123; el.style.fontWeight = binding.value &#125; &#125;, 'fontsize': function (el, binding) &#123; // 注意：这个 function 等同于 把 代码写到了 bind 和 update 中去 el.style.fontSize = parseInt(binding.value) + 'px' &#125; &#125; &#125;) // 过滤器的定义语法 // Vue.filter('过滤器的名称', function()&#123;&#125;) // 过滤器中的 function ，第一个参数，已经被规定死了，永远都是 过滤器 管道符前面 传递过来的数据 /* Vue.filter('过滤器的名称', function (data) &#123; return data + '123' &#125;) */ // document.getElementById('search').focus() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 过滤器调用时候的格式 &#123;&#123; name | 过滤器的名称 &#125;&#125; --&gt; 根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 123456789101112131415&lt;tr v-for=&quot;item in list | filterBy searchName in &apos;name&apos;&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 123&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 12345678910111213141516171819&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 123456789search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 这是基本的过滤器使用方法 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; msg | msgFormat('疯狂+1', '123') | test &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter('msgFormat', function (msg, arg, arg2) &#123; // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return msg.replace(/单纯/g, arg + arg2) &#125;) Vue.filter('test', function (msg) &#123; return msg + '========' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人' &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 私有过滤器 HTML元素： 1&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（1）vue基础和指令]]></title>
    <url>%2F2019%2F01%2F11%2F%EF%BC%881%EF%BC%89vue%E5%9F%BA%E7%A1%80%E5%92%8Cvue%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[vue.js vue前言什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1. 导入Vue的包 --&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 将来 new 的Vue实例，会控制这个 元素中的所有内容 --&gt; &lt;!-- Vue 实例所控制的这个元素区域，就是我们的 V --&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 2. 创建一个Vue的实例 // 当我们导入包之后，在浏览器的内存中，就多了一个 Vue 构造函数 // 注意：我们 new 出来的这个 vm 对象，就是我们 MVVM中的 VM调度者 var vm = new Vue(&#123; el: '#app', // 表示，当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域 // 这里的 data 就是 MVVM中的 M，专门用来保存 每个页面的数据的 data: &#123; // data 属性中，存放的是 el 中要用到的数据 msg: '欢迎学习Vue' // 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码里， 里面的是相当于V，new出来的这个对象就是实例，实例里面的data就是M vue基本指令v-cloak123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 使用 v-cloak 能够解决 插值表达式闪烁的问题 --&gt; &lt;p v-cloak&gt;++++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt; &lt;/div&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123', &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-cloak实际使用的效果就是，当网速慢，加载时间长的时候，使用插值表达式不会出现 这种样子 v-text——内容绑定123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; /* display: none; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 使用 v-cloak 能够解决 插值表达式闪烁的问题 --&gt; &lt;p v-cloak&gt;++++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt; &lt;h4 v-text="msg"&gt;==================&lt;/h4&gt; &lt;!-- 默认 v-text 是没有闪烁问题的 --&gt; &lt;!-- v-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 --&gt; &lt;/div&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123', &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 默认 v-text 是没有闪烁问题的 v-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 v-html1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; /* display: none; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div v-html="msg2"&gt;1212112&lt;/div&gt; &lt;/div&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg2: '&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;', &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-html 可以将文本中的这样的显示出相应的格式。 v-bind——属性绑定123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; /* display: none; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- v-bind: 是 Vue中，提供的用于绑定属性的指令 --&gt; &lt;input type="button" value="按钮" v-bind:title="mytitle + '123'"&gt; &lt;!-- 注意： v-bind: 指令可以被简写为 :要绑定的属性 --&gt; &lt;!-- v-bind 中，可以写合法的JS表达式 --&gt; &lt;/div&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; mytitle: '这是一个自己定义的title' &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; v-on——事件绑定1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; /* display: none; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- Vue 中提供了 v-on: 事件绑定机制 --&gt; &lt;!-- &lt;input type="button" value="按钮" :title="mytitle + '123'" v-on:click="alert('hello')"&gt; --&gt; &lt;input type="button" value="按钮" @click="show"&gt; &lt;/div&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; &#125;, methods: &#123; // 这个 methods属性中定义了当前Vue实例所有可用的方法 show: function () &#123; alert('Hello') &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件修饰符 .stop 阻止冒泡（这是从里往外） .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式（这是从外往里） .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;style&gt; .inner &#123; height: 150px; background-color: darkcyan; &#125; .outer &#123; padding: 40px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 使用 .stop 阻止冒泡 --&gt; &lt;!-- &lt;div class="inner" @click="div1Handler"&gt; &lt;input type="button" value="戳他" @click.stop="btnHandler"&gt; &lt;/div&gt; --&gt; &lt;!-- 使用 .prevent 阻止默认行为 --&gt; &lt;!-- &lt;a href="http://www.baidu.com" @click.prevent="linkClick"&gt;有问题，先去百度&lt;/a&gt; --&gt; &lt;!-- 使用 .capture 实现捕获触发事件的机制 --&gt; &lt;!-- &lt;div class="inner" @click.capture="div1Handler"&gt; &lt;input type="button" value="戳他" @click="btnHandler"&gt; &lt;/div&gt; --&gt; &lt;!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 --&gt; &lt;!-- &lt;div class="inner" @click="div1Handler"&gt; &lt;input type="button" value="戳他" @click="btnHandler"&gt; &lt;/div&gt; --&gt; &lt;!-- 使用 .once 只触发一次事件处理函数 --&gt; &lt;!-- &lt;a href="http://www.baidu.com" @click.prevent.once="linkClick"&gt;有问题，先去百度&lt;/a&gt; --&gt; &lt;!-- 演示： .stop 和 .self 的区别 --&gt; &lt;!-- &lt;div class="outer" @click="div2Handler"&gt; &lt;div class="inner" @click="div1Handler"&gt; &lt;input type="button" value="戳他" @click.stop="btnHandler"&gt; &lt;/div&gt; &lt;/div&gt; --&gt; &lt;!-- .self 只会阻止自己身上冒泡行为的触发，并不会真正阻止 冒泡的行为 --&gt; &lt;!-- &lt;div class="outer" @click="div2Handler"&gt; &lt;div class="inner" @click.self="div1Handler"&gt; &lt;input type="button" value="戳他" @click="btnHandler"&gt; &lt;/div&gt; &lt;/div&gt; --&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; div1Handler() &#123; console.log('这是触发了 inner div 的点击事件') &#125;, btnHandler() &#123; console.log('这是触发了 btn 按钮 的点击事件') &#125;, linkClick() &#123; console.log('触发了连接的点击事件') &#125;, div2Handler() &#123; console.log('这是触发了 outer div 的点击事件') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-model——双向数据绑定1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt; &lt;!-- v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 --&gt; &lt;!-- &lt;input type="text" v-bind:value="msg" style="width:100%;"&gt; --&gt; &lt;!-- 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 --&gt; &lt;!-- 注意： v-model 只能运用在 表单元素中 --&gt; &lt;!-- input(radio, text, address, email....) select checkbox textarea --&gt; &lt;input type="text" style="width:100%;" v-model="msg"&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '大家都是好学生，爱敲代码，爱学习，爱思考，简直是完美，没瑕疵！' &#125;, methods: &#123; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-for——循环循环普通数组123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;p&gt;&#123;&#123;list[0]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[1]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[2]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[3]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[4]&#125;&#125;&lt;/p&gt; --&gt; &lt;p v-for="(item, i) in list"&gt;索引值：&#123;&#123;i&#125;&#125; --- 每一项：&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [1, 2, 3, 4, 5, 6] &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 循环对象数组12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p v-for="(user, i) in list"&gt;Id：&#123;&#123; user.id &#125;&#125; --- 名字：&#123;&#123; user.name &#125;&#125; --- 索引：&#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [ &#123; id: 1, name: 'zs1' &#125;, &#123; id: 2, name: 'zs2' &#125;, &#123; id: 3, name: 'zs3' &#125;, &#123; id: 4, name: 'zs4' &#125; ] &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 循环对象12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 注意：在遍历对象身上的键值对的时候， 除了 有 val key ,在第三个位置还有 一个 索引 --&gt; &lt;p v-for="(val, key, i) in user"&gt;值是： &#123;&#123; val &#125;&#125; --- 键是： &#123;&#123;key&#125;&#125; -- 索引： &#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; user: &#123; id: 1, name: '托尼·屎大颗', gender: '男' &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 迭代数字1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- in 后面我们放过 普通数组，对象数组，对象， 还可以放数字 --&gt; &lt;!-- 注意：如果使用 v-for 迭代数字的话，前面的 count 值从 1 开始 --&gt; &lt;p v-for="count in 10"&gt;这是第 &#123;&#123; count &#125;&#125; 次循环&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-for循环中key属性的使用 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div&gt; &lt;label&gt;Id: &lt;input type="text" v-model="id"&gt; &lt;/label&gt; &lt;label&gt;Name: &lt;input type="text" v-model="name"&gt; &lt;/label&gt; &lt;input type="button" value="添加" @click="add"&gt; &lt;/div&gt; &lt;!-- 注意： v-for 循环的时候，key 属性只能使用 number获取string --&gt; &lt;!-- 注意： key 在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 --&gt; &lt;!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须 在使用 v-for 的同时，指定 唯一的 字符串/数字 类型 :key 值 --&gt; &lt;p v-for="item in list" :key="item.id"&gt; &lt;input type="checkbox"&gt;&#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', list: [ &#123; id: 1, name: '李斯' &#125;, &#123; id: 2, name: '嬴政' &#125;, &#123; id: 3, name: '赵高' &#125;, &#123; id: 4, name: '韩非' &#125;, &#123; id: 5, name: '荀子' &#125; ] &#125;, methods: &#123; add() &#123; // 添加方法 this.list.unshift(&#123; id: this.id, name: this.name &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-if和v-show1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;input type="button" value="toggle" @click="toggle"&gt; --&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;!-- v-if 的特点：每次都会重新删除或创建元素 --&gt; &lt;!-- v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 --&gt; &lt;!-- v-if 有较高的切换性能消耗 --&gt; &lt;!-- v-show 有较高的初始渲染消耗 --&gt; &lt;!-- 如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show --&gt; &lt;!-- 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if --&gt; &lt;h3 v-if="flag"&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-show="flag"&gt;这是用v-show控制的元素&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123; /* toggle() &#123; this.flag = !this.flag &#125; */ &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 定时器使用——跑马灯效果例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1. 导入Vue包 --&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 2. 创建一个要控制的区域 --&gt; &lt;div id="app"&gt; &lt;input type="button" value="浪起来" @click="lang"&gt; &lt;input type="button" value="低调" @click="stop"&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;script&gt; // 注意：在 VM实例中，如果想要获取 data 上的数据，或者 想要调用 methods 中的 方法，必须通过 this.数据属性名 或 this.方法名 来进行访问，这里的this，就表示 我们 new 出来的 VM 实例对象 var vm = new Vue(&#123; el: '#app', data: &#123; msg: '猥琐发育，别浪~~！', intervalId: null // 在data上定义 定时器Id &#125;, methods: &#123; lang() &#123; // console.log(this.msg) // 获取到头的第一个字符 // this if (this.intervalId != null) return; this.intervalId = setInterval(() =&gt; &#123; var start = this.msg.substring(0, 1) // 获取到 后面的所有字符 var end = this.msg.substring(1) // 重新拼接得到新的字符串，并赋值给 this.msg this.msg = end + start &#125;, 400) // 注意： VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把 最新的数据，从data 上同步到页面中去；【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】 &#125;, stop() &#123; // 停止定时器 clearInterval(this.intervalId) // 每当清除了定时器之后，需要重新把 intervalId 置为 null this.intervalId = null; &#125; &#125; &#125;) // 分析： // 1. 给 【浪起来】 按钮，绑定一个点击事件 v-on @ // 2. 在按钮的事件处理函数中，写相关的业务逻辑代码：拿到 msg 字符串，然后 调用 字符串的 substring 来进行字符串的截取操作，把 第一个字符截取出来，放到最后一个位置即可； // 3. 为了实现点击下按钮，自动截取的功能，需要把 2 步骤中的代码，放到一个定时器中去； &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Vue中使用样式使用class样式 数组 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, isactive?&apos;active&apos;:&apos;&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, &#123;&apos;active&apos;: isactive&#125;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class=&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;style&gt; .red &#123; color: red; &#125; .thin &#123; font-weight: 200; &#125; .italic &#123; font-style: italic; &#125; .active &#123; letter-spacing: 0.5em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;h1 class="red thin"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 第一种使用方式，直接传递一个数组，注意： 这里的 class 需要使用 v-bind 做数据绑定 --&gt; &lt;!-- &lt;h1 :class="['thin', 'italic']"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在数组中使用三元表达式 --&gt; &lt;!-- &lt;h1 :class="['thin', 'italic', flag?'active':'']"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在数组中使用 对象来代替三元表达式，提高代码的可读性 --&gt; &lt;!-- &lt;h1 :class="['thin', 'italic', &#123;'active':flag&#125; ]"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在为 class 使用 v-bind 绑定 对象的时候，对象的属性是类名，由于 对象的属性可带引号，也可不带引号，所以 这里我没写引号； 属性的值 是一个标识符 --&gt; &lt;h1 :class="classObj"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: true, classObj: &#123; red: true, thin: true, italic: false, active: false &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style=&quot;&#123;color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;&#125;&quot;&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;, h1StyleObj2: &#123; fontStyle: &apos;italic&apos; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt; 示例代码： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 对象就是无序键值对的集合 --&gt; &lt;!-- &lt;h1 :style="styleObj1"&gt;这是一个h1&lt;/h1&gt; --&gt; &lt;h1 :style="[ styleObj1, styleObj2 ]"&gt;这是一个h1&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; styleObj1: &#123; color: 'red', 'font-weight': 200 &#125;, styleObj2: &#123; 'font-style': 'italic' &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
