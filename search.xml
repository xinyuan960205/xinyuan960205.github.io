<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[github pages-hexo-next 博客搭建]]></title>
    <url>%2F2019%2F01%2F21%2Fgithub-pages-hexo-next-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期]]></title>
    <url>%2F2019%2F01%2F18%2Fvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="修改msg" @click="msg='No'"&gt; &lt;h3 id="h3"&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'ok' &#125;, methods: &#123; show() &#123; console.log('执行了show方法') &#125; &#125;, beforeCreate() &#123; // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它 // console.log(this.msg) // this.show() // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 &#125;, created() &#123; // 这是遇到的第二个生命周期函数 // console.log(this.msg) // this.show() // 在 created 中，data 和 methods 都已经被初始化好了！ // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作 &#125;, beforeMount() &#123; // 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中 // console.log(document.getElementById('h3').innerText) // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 &#125;, mounted() &#123; // 这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 // console.log(document.getElementById('h3').innerText) // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 &#125;, // 接下来的是运行中的两个事件 beforeUpdate() &#123; // 这时候，表示 我们的界面还没有被更新【数据被更新了吗？ 数据肯定被更新了】 /* console.log('界面上元素的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) */ // 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步 &#125;, updated() &#123; console.log('界面上元素的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) // updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2019%2F01%2F16%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex 为什么要使用概念vuex 是 Vue 配套的 公共数据管理工具，它可以把一些共享的数据，保存到 vuex 中，方便 整个程序中的任何组件直接获取或修改我们的公共数据； Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 vuex安装首先在webpack创建的vue-cli工程下，通过npm命令行，安装vuex 1npm install vuex --save 然后 , 在 main.js 中导入包 : 1234567import vuex from 'vuex'Vue.use(vuex);var store = new vuex.Store(&#123;//store对象 state:&#123; show:false &#125;&#125;) 再然后 , 在实例化 Vue对象时加入 store 对象 : 1234567new Vue(&#123; el: '#app', router, store, //将vuex创建的store挂载到VM实例上，只要挂载到VM上，就可以任何组件使用store来存取数据 template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 完成上述的步骤，vue中类似于$store.state.show 的操作就可以使用了 vuex核心概念store什么是store每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 创建store官网上和教程上给的都是在main.js上，也可以创建store.js把下面的代码写在store.js里面，在main.js里面引用store.js（后面给出了具体的操作） 12345678910111213141516// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; //把state想象成组件中的data，专门用来存储数据的 count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;)//这里的state就相当于data//这里的mutations就相当于methods 前面为了方便 , 我们把 store 对象写在了 main.js 里面 , 但实际上为了便于日后的维护 , 我们分开写更好 , 我们在 src 目录下 , 新建一个 store 文件夹 , 然后在里面新建一个 index.js : 123456789import Vue from 'vue'import vuex from 'vuex'Vue.use(vuex);export default new vuex.Store(&#123; state:&#123; show:false &#125;&#125;) 那么相应的 , 在 main.js 里的代码应该改成 : 12345678910//vueximport store from './store'new Vue(&#123; el: '#app', router, store,//使用store template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 这样就把 store 分离出去了 , 那么还有一个问题是 : 这里 $store.state.show 无论哪个组件都可以使用 , 那组件多了之后 , 状态也多了 , 这么多状态都堆在 store 文件夹下的 index.js 不好维护怎么办 ? 我们可以使用 vuex 的 modules , 把 store 文件夹下的 index.js 改成 : 1234567891011import Vue from 'vue'import vuex from 'vuex'Vue.use(vuex);import dialog_store from '../components/dialog_store.js';//引入某个store对象export default new vuex.Store(&#123; modules: &#123; dialog: dialog_store &#125;&#125;) 这里我们引用了一个 dialog_store.js , 在这个 js 文件里我们就可以单独写 dialog 组件的状态了 : 12345export default &#123; state:&#123; show:false &#125;&#125; 做出这样的修改之后 , 我们将之前我们使用的 $store.state.show 统统改为 $store.state.dialog.show 即可。 如果还有其他的组件需要使用 vuex , 就新建一个对应的状态文件 , 然后将他们加入 store 文件夹下的 index.js 文件中的 modules 中。 1234modules: &#123; dialog: dialog_store, other: other,//其他组件&#125; mutations访问store中的数据如果在组件中想要访问store中的数据，只能通过this.$store.state.***来访问 修改store中的数据1this.$store.state.count++; //千万不要这么做，这不符合vuex的设计理念 注意，如果要操作store中的state值，只能通过调用mutations提供的方法，才能操作对应的数据，不推荐直接操作state中的数据。因为，万一数据出现了紊乱，不能快速定位到错误的原因。因为每个组件都有操作数据的方法。 如果组件要调用mutations中的方法，只能使用this.$store.commit(&#39;方法名&#39;)。 mutations方法的提交参数1234567891011121314const store = new Vuex.Store(&#123; state: &#123; //把state想象成组件中的data，专门用来存储数据的 count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125;, substract(state,c)&#123; &#125; &#125;&#125;) 12345678910111213&lt;script&gt;export default&#123;data()&#123;&#125;,methods:&#123; remove()&#123; //vue组件中调用mutations中的方法 this.$store.commit("substract",3); &#125;&#125;&#125;&lt;/script&gt; mutations的函数参数列表中，最多支持两个参数，其中，参数1：是state状态；参数2：通过commit提交的参数 getters包装数据12345678910111213141516171819const store = new Vuex.Store(&#123; state: &#123; //把state想象成组件中的data，专门用来存储数据的 count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125;, substract(state,c)&#123; //方法内容 &#125; getters()&#123; optCount: function(state)&#123; return '当前最新的count值是：' + state.count &#125; &#125; &#125;&#125;) 注意：这里的getters，只负责对外提供数据，不负责修改数据，如果想要修改state中的数据，应该去找mutations中的方法 getters中的方法和过滤器中额方法类似，因为过滤器和getters都没有修改数据，只是把原数据做了一层包装，提供给了调用者。 其次，getters也和computed比较像，只要state中的数据发生了变化，那么如果getters正好也引用了这个数据，那么，就会立刻触发getters的重新求值。 actions多个 state 的操作 , 使用 mutations 会来触发会比较好维护 , 那么需要执行多个 mutations 就需要用 action 了: 1234567891011121314151617export default &#123; state:&#123;//state show:false &#125;, mutations:&#123; switch_dialog(state)&#123;//这里的state对应着上面这个state state.show = state.show?false:true; //你还可以在这里执行其他的操作改变state &#125; &#125;, actions:&#123; switch_dialog(context)&#123;//这里的context和我们使用的$store拥有相同的对象和方法 context.commit('switch_dialog'); //你还可以在这里触发其他的mutations方法 &#125;, &#125;&#125; 那么 , 在之前的父组件中 , 我们需要做修改 , 来触发 action 里的 switch_dialog 方法: 123456789101112131415&lt;template&gt; &lt;div id="app"&gt; &lt;a href="javascript:;" @click="$store.dispatch('switch_dialog')"&gt;点击&lt;/a&gt; &lt;t-dialog&gt;&lt;/t-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import dialog from './components/dialog.vue'export default &#123; components:&#123; "t-dialog":dialog &#125;&#125;&lt;/script&gt; 使用 $store.dispatch(&#39;switch_dialog&#39;) 来触发 action 中的 switch_dialog 方法。 官方推荐 , 将异步操作放在 action 中。 mapState、mapGetters、mapActions(未看)很多时候 , $store.state.dialog.show 、$store.dispatch(&#39;switch_dialog&#39;) 这种写法又长又臭 , 很不方便 , 我们没使用 vuex 的时候 , 获取一个状态只需要 this.show , 执行一个方法只需要 this.switch_dialog 就行了 , 使用 vuex 使写法变复杂了 ? 使用 mapState、mapGetters、mapActions 就不会这么复杂了。 以 mapState 为例 : 12345678910111213141516&lt;template&gt; &lt;el-dialog :visible.sync="show"&gt;&lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex';export default &#123; computed:&#123; //这里的三点叫做 : 扩展运算符 ...mapState(&#123; show:state=&gt;state.dialog.show &#125;), &#125;&#125;&lt;/script&gt; 相当于 : 1234567891011121314&lt;template&gt; &lt;el-dialog :visible.sync="show"&gt;&lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex';export default &#123; computed:&#123; show()&#123; return this.$store.state.dialog.show; &#125; &#125;&#125;&lt;/script&gt; mapGetters、mapActions 和 mapState 类似 , mapGetters 一般也写在 computed 中 , mapActions 一般写在 methods中。]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目 element国际化]]></title>
    <url>%2F2019%2F01%2F16%2Fvue%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[vue项目 element国际化说明Element组件自身提供国际化，支持多种语言，可以在src/main.js添加如下代码，来令Element的组件使用指定语言。 123import ElementUI from 'element-ui'import locale from 'element-ui/lib/locale/lang/en'Vue.use(ElementUI, &#123; locale &#125;) 但上方代码只会令Element的组件使用指定语言，并不会让我们自己写的代码能支持国际化，因此我们要加入自己的i18n。 另外以上是使用指定的其他一种语言，为了能够切换多种语言，我们要导入多种语言。 实现以下以实现中文和英文切换为例： 安装vue-i18n： 1npm install vue-i18n --save 创建本系统的中文语言文件src/assets/lang/zh-cn.js 1234567891011export default &#123; common: &#123; ok: '确认', cancel: '取消' &#125;, login: &#123; login: '登录', register: '注册', ... &#125;&#125; 创建本系统的英文语言文件src/assets/lang/en.js 1234567891011export default &#123; common: &#123; ok: 'OK', cancel: 'Cancle' &#125;, login: &#123; login: 'Login', register: 'Register', ... &#125;&#125; 修改src/main.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router/index'import Mock from './mock/index'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import 'font-awesome/scss/font-awesome.scss'import VueScroll from 'vuescroll'import 'vuescroll/dist/vuescroll.css'import './assets/css/common.scss'/* 1. 导入国际化相关依赖 */import VueI18n from 'vue-i18n'import myEnLocale from './assets/lang/en'import myZhLocale from './assets/lang/zh-cn'import enLocale from 'element-ui/lib/locale/lang/en'import zhLocale from 'element-ui/lib/locale/lang/zh-CN'Vue.config.productionTip = false/* mockjs */Mock.mockData()/* vue-i18n */Vue.use(VueI18n)// 2.1 支持两种语言，每种语言需要合并自己书写的语言文件和element-ui的同语言文件const messages = &#123; 'en': Object.assign(myEnLocale, enLocale), 'zh-cn': Object.assign(myZhLocale, zhLocale)&#125;// 2.2 加载用户语言设置，你也可以把此值存放在后台const lang = localStorage.getItem('user-language') || 'zh-cn'// 2. 实例化VueI18nconst i18n = new VueI18n(&#123; locale: lang, // 2.2 messages // 2.1&#125;)/* element-ui */Vue.use(ElementUI, &#123; // 3. element-ui默认支持vue-i18n@5.x版本，6.x以上的版本需要添加此配置项，当前已8.x i18n: (key, value) =&gt; i18n.t(key, value)&#125;)/* vuescroll */Vue.use(VueScroll, &#123;ops: &#123;bar: &#123;background: '#C0C4CC'&#125;&#125;&#125;)/* eslint-disable no-new */new Vue(&#123; el: '#app', router, i18n, // 4. 将i18n挂载到根实例 components: &#123;App&#125;, template: '&lt;App/&gt;'&#125;) 使用：以下代码举例了在vue组件中如何使用语言文件配置的值 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;!-- 1. 属性中使用，记得使用v-bind，即不要遗漏前面的冒号 --&gt; &lt;input :placeholder="$t('login.login')"/&gt; &lt;!-- 2. HTML中使用 --&gt; &lt;button&gt;&#123;&#123; $t("common.ok") &#125;&#125;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; // 3. js中使用 const cancel = this.$t('common.cancel') &#125;&#125;&lt;/script&gt; 代码里举了三个例子，分别是v-bind绑定的、HTML里直接使用的和js中使用的，直接用this引用 切换语言：记录并切换语言 12localStorage.setItem('user-language', 'zh-cn')this.$i18n.locale = 'zh-cn' 项目实现的具体代码TheLayoutHeader.vuetemplate部分12345678910111213141516&lt;div class="navbar-text" @click="clickLangue"&gt; &lt;el-dropdown trigger="click" @command="changeLanguage" id="langDropDown" size="medium"&gt; &lt;p class="user-info" style="height: 10px"&gt; &#123;&#123; $t('header.languageSelect') &#125;&#125; &lt;i class="el-icon-arrow-down el-icon--right drop-icon" id="langDropIcon"&gt;&lt;/i&gt; &lt;/p&gt; &lt;el-dropdown-menu slot="dropdown"&gt; &lt;el-dropdown-item command="zh-cn" :disabled="this.lang==='zh-cn'"&gt; &#123;&#123;$t('header.langZh')&#125;&#125; &lt;/el-dropdown-item&gt; &lt;el-dropdown-item command="en" :disabled="this.lang==='en'"&gt; &#123;&#123;$t('header.langEn')&#125;&#125; &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt;&lt;/div&gt; 使用了element的下拉菜单，显示菜单的名称已经实现国际化。 script部分1234567891011121314151617//改变语言 changeLanguage (language) &#123; localStorage.setItem('user-language', language) this.$i18n.locale = language this.lang = language this.timeFormate(new Date()) &#125;,// clickLangue () &#123; let langDropIcon = document.getElementById('langDropIcon') if (this.langDrop) &#123; langDropIcon.style.transform = 'rotate(0deg)' &#125; else &#123; langDropIcon.style.transform = 'rotate(-180deg)' &#125; this.langDrop = !this.langDrop &#125;, 建立文字国际化库在./src/assets/lang/en.js 1234567891011121314151617181920212223242526272829export default &#123; common: &#123; ok: 'OK', cancel: 'Cancel' &#125;, login: &#123; login: 'Login', register: 'Register', account: 'Account', password: 'Password', showPass: 'show password', forgetPass: 'forget password?', modifyPass: 'Change password', oldPass: 'Old Password', newPass: 'New Password', checkPass: 'Repeat password', inputAccount: 'Please input account', inputPass: 'Please input password', inputOldPass: 'Please input old password', inputNewPass: 'Please input new password', inputCheckPass: 'Please input password again', errorCheckPass: 'Password not the same!', loginSuccess: 'Login Success!', registerSuccess: 'Register Success!', changePassMessage: 'Change password?', tip: 'Tip', changeSuccess: 'Change Success', cancel: 'Cancel!' &#125;, 在./src/assets/lang/zh-cn.js 1234567891011121314151617181920212223242526272829export default &#123; common: &#123; ok: '确认', cancel: '取消' &#125;, login: &#123; login: '登录', register: '注册', account: '账号', password: '密码', showPass: '显示密码', forgetPass: '忘记密码？', modifyPass: '修改密码', oldPass: '旧密码', newPass: '新密码', checkPass: '重复密码', inputAccount: '请输入账号', inputPass: '请输入密码', inputOldPass: '请输入旧密码', inputNewPass: '请输入新密码', inputCheckPass: '请再次输入密码', errorCheckPass: '两次输入密码不一致!', loginSuccess: '登录成功！', registerSuccess: '注册成功！', changePassMessage: '确认修改密码吗？', tip: '提示', changeSuccess: '修改成功', cancel: '已取消！' &#125;, 自己建立自己的文本库，如果觉得可以是共用的可以放到common里面，最好一个vue组件就建立一个 例如： TheLayoutHeader.vue 1234567891011121314151617181920212223TheLayoutHeader:&#123; lock:'锁定', unlock:'解锁', logout:'退出', year:'年', month:'月', day:'日', configurationManagement:'配置管理', basicConfigurationManagement:'基础配置管理', locationConfigurationManagement:'机房配置管理', cabinetConfigurationManagement:'机架配置管理', deviceCreatPort:'业务端口配置管理', topologyManagement:'拓扑管理', subnetConfigurationManagement:'子网配置管理', linkConfigurationManagement:'链路配置管理', deviceConfigurationManagement:'网元配置管理', controlManagement:'控制管理', businessManagement:'业务管理', alarmManagement:'故障管理', performanceManagement:'性能管理', safeManagemnet:'安全管理',&#125;, 12345678910111213141516171819202122TheLayoutHeader:&#123; lock:'lock', unlock:'unlock', logout:'logout', year:'.', month:'.', day:'', configurationManagement:'configurationManagement', basicConfigurationManagement:'basicConfigurationManagement', locationConfigurationManagement:'locationConfigurationManagement', cabinetConfigurationManagement:'cabinetConfigurationManagement', deviceCreatPort:'deviceCreatPort', topologyManagement:'topologyManagement', subnetConfigurationManagement:'subnetConfigurationManagement', linkConfigurationManagement:'linkConfigurationManagement', deviceConfigurationManagement:'deviceConfigurationManagement', controlManagement:'controlManagement', businessManagement:'businessManagement', alarmManagement:'alarmManagement', performanceManagement:'performanceManagement', safeManagemnet:'safeManagemnet',&#125;,]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue自定义按键、指令]]></title>
    <url>%2F2019%2F01%2F15%2Fvue%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%94%AE%E3%80%81%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[vue自定义按键vue自定义按键1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./lib/bootstrap-3.3.7.css"&gt; &lt;!-- 需要用到Jquery吗？？？ --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &#123;&#123;1+1&#125;&#125; --&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body form-inline"&gt; &lt;label&gt; Name: //按enter实现 &lt;input type="text" class="form-control" v-model="name" @keyup.enter="add"&gt; //113是F2的码，所以按F2实现 &lt;input type="text" class="form-control" v-model="name" @keyup.113="add"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义全局指令——让文本框获取焦点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./lib/bootstrap-3.3.7.css"&gt; &lt;!-- 需要用到Jquery吗？？？ --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &#123;&#123;1+1&#125;&#125; --&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body form-inline"&gt; &lt;label&gt; 搜索名称关键字： &lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 --&gt; &lt;input type="text" class="form-control" v-model="keywords" id="search" v-focus v-color="'green'"&gt; &lt;/label&gt; &lt;/div&gt; &lt;script&gt; // 使用 Vue.directive() 定义全局的指令 v-focus // 其中：参数1 ： 指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀, // 但是： 在调用的时候，必须 在指令名称前 加上 v- 前缀来进行调用 // 参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive('focus', &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 // 注意： 在每个 函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用钩子函数的第二个binding获得参数值在html中的输入框中，设置v-color 在script中，自定义的bind函数的第二个参数binding获取值“green” 12345&lt;label&gt; 搜索名称关键字： &lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 --&gt; &lt;input type="text" class="form-control" v-model="keywords" id="search" v-focus v-color="'green'"&gt;&lt;/label&gt; 1234567891011121314151617&lt;script&gt; // 自定义一个 设置字体颜色的 指令 Vue.directive('color', &#123; // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 bind: function (el, binding) &#123; // el.style.color = 'red' // console.log(binding.name) // 和样式相关的操作，一般都可以在 bind 执行 // console.log(binding.value) // console.log(binding.expression) el.style.color = binding.value &#125; &#125;)&lt;/script&gt; 定义私有指令123&lt;div id="app2"&gt; &lt;h3 v-color="'pink'" v-fontweight="900" v-fontsize="50"&gt;&#123;&#123; dt | dateFormat &#125;&#125;&lt;/h3&gt; &lt;/div&gt; 123456789101112131415161718&lt;script&gt;// 如何自定义一个私有的过滤器（局部） var vm2 = new Vue(&#123; el: '#app2', data: &#123; dt: new Date() &#125;, methods: &#123;&#125;, filters: &#123;&#125;, directives: &#123; // 自定义私有指令 'fontweight': &#123; // 设置字体粗细的 bind: function (el, binding) &#123; el.style.fontWeight = binding.value &#125; &#125; &#125; &#125;)&lt;/script&gt; 指令的简写方式123&lt;div id="app2"&gt; &lt;h3 v-color="'pink'" v-fontweight="900" v-fontsize="50"&gt;&#123;&#123; dt | dateFormat &#125;&#125;&lt;/h3&gt; &lt;/div&gt; 12345678910111213141516&lt;script&gt;// 如何自定义一个私有的过滤器（局部） var vm2 = new Vue(&#123; el: '#app2', data: &#123; dt: new Date() &#125;, methods: &#123;&#125;, filters: &#123;&#125;, directives: &#123; // 自定义私有指令 'fontsize': function (el, binding) &#123; // 注意：这个 function 等同于 把 代码写到了 bind 和 update 中去 el.style.fontSize = parseInt(binding.value) + 'px' &#125; &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-resource]]></title>
    <url>%2F2019%2F01%2F15%2Fvue-resourse%2F</url>
    <content type="text"><![CDATA[vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子； vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求： 12345getInfo() &#123; // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; &#123; console.log(res.body); &#125;)&#125; 发送post请求： 12345678910postInfo() &#123; var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: 'zs' &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送JSONP请求获取数据： 123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 代码样式： 12345678910111213141516171819getInfo() &#123; // 发起get请求 // 当发起get请求之后， 通过 .then 来设置成功的回调函数 this.$http.get('http://vue.studyit.io/api/getlunbo').then(function (result) &#123; // 通过 result.body 拿到服务器返回的成功的数据 // console.log(result.body) &#125;) &#125;, postInfo() &#123; // 发起 post 请求 application/x-wwww-form-urlencoded // 手动发起的 Post 请求，默认没有表单格式，所以，有的服务器处理不了 // 通过 post 方法的第三个参数， &#123; emulateJSON: true &#125; 设置 提交的内容类型 为 普通表单数据格式 this.$http.post('http://vue.studyit.io/api/post', &#123;&#125;, &#123; emulateJSON: true &#125;).then(result =&gt; &#123; console.log(result.body) &#125;) &#125;, jsonpInfo() &#123; // 发起JSONP 请求 this.$http.jsonp('http://vue.studyit.io/api/jsonp').then(result =&gt; &#123; console.log(result.body) &#125;) &#125;]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue过滤器]]></title>
    <url>%2F2019%2F01%2F14%2Fvue%20%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[品牌列表案例源码，这里面用到了这次学习的所有内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./lib/bootstrap-3.3.7.css"&gt; &lt;!-- 需要用到Jquery吗？？？ --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &#123;&#123;1+1&#125;&#125; --&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body form-inline"&gt; &lt;label&gt; Id: &lt;input type="text" class="form-control" v-model="id"&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type="text" class="form-control" v-model="name" @keyup.f2="add"&gt; &lt;/label&gt; &lt;!-- 在Vue中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了 --&gt; &lt;input type="button" value="添加" class="btn btn-primary" @click="add()"&gt; &lt;label&gt; 搜索名称关键字： &lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 --&gt; &lt;input type="text" class="form-control" v-model="keywords" id="search" v-focus v-color="'green'"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class="table table-bordered table-hover table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 之前， v-for 中的数据，都是直接从 data 上的list中直接渲染过来的 --&gt; &lt;!-- 现在， 我们自定义了一个 search 方法，同时，把 所有的关键字，通过传参的形式，传递给了 search 方法 --&gt; &lt;!-- 在 search 方法内部，通过 执行 for 循环， 把所有符合 搜索关键字的数据，保存到 一个新数组中，返回 --&gt; &lt;tr v-for="item in search(keywords)" :key="item.id"&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td v-text="item.name"&gt;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.ctime | dateFormat() &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id="app2"&gt; &lt;h3 v-color="'pink'" v-fontweight="900" v-fontsize="50"&gt;&#123;&#123; dt | dateFormat &#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 全局的过滤器， 进行时间的格式化 // 所谓的全局过滤器，就是所有的VM实例都共享的 Vue.filter('dateFormat', function (dateStr, pattern = "") &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() // return y + '-' + m + '-' + d if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125;) // 自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113 // 使用 Vue.directive() 定义全局的指令 v-focus // 其中：参数1 ： 指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀, // 但是： 在调用的时候，必须 在指令名称前 加上 v- 前缀来进行调用 // 参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive('focus', &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 // 注意： 在每个 函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125; &#125;) // 自定义一个 设置字体颜色的 指令 Vue.directive('color', &#123; // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 bind: function (el, binding) &#123; // el.style.color = 'red' // console.log(binding.name) // 和样式相关的操作，一般都可以在 bind 执行 // console.log(binding.value) // console.log(binding.expression) el.style.color = binding.value &#125; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', keywords: '', // 搜索的关键字 list: [ &#123; id: 1, name: '奔驰', ctime: new Date() &#125;, &#123; id: 2, name: '宝马', ctime: new Date() &#125; ] &#125;, methods: &#123; add() &#123; // 添加的方法 // console.log('ok') // 分析： // 1. 获取到 id 和 name ,直接从 data 上面获取 // 2. 组织出一个对象 // 3. 把这个对象，调用 数组的 相关方法，添加到 当前 data 上的 list 中 // 4. 注意：在Vue中，已经实现了数据的双向绑定，每当我们修改了 data 中的数据，Vue会默认监听到数据的改动，自动把最新的数据，应用到页面上； // 5. 当我们意识到上面的第四步的时候，就证明大家已经入门Vue了，我们更多的是在进行 VM中 Model 数据的操作，同时，在操作Model数据的时候，指定的业务逻辑操作； var car = &#123; id: this.id, name: this.name, ctime: new Date() &#125; this.list.push(car) this.id = this.name = '' &#125;, del(id) &#123; // 根据Id删除数据 // 分析： // 1. 如何根据Id，找到要删除这一项的索引 // 2. 如果找到索引了，直接调用 数组的 splice 方法 /* this.list.some((item, i) =&gt; &#123; if (item.id == id) &#123; this.list.splice(i, 1) // 在 数组的 some 方法中，如果 return true，就会立即终止这个数组的后续循环 return true; &#125; &#125;) */ var index = this.list.findIndex(item =&gt; &#123; if (item.id == id) &#123; return true; &#125; &#125;) // console.log(index) this.list.splice(index, 1) &#125;, search(keywords) &#123; // 根据关键字，进行数据的搜索 /* var newList = [] this.list.forEach(item =&gt; &#123; if (item.name.indexOf(keywords) != -1) &#123; newList.push(item) &#125; &#125;) return newList */ // 注意： forEach some filter findIndex 这些都属于数组的新方法， // 都会对数组中的每一项，进行遍历，执行相关的操作； return this.list.filter(item =&gt; &#123; // if(item.name.indexOf(keywords) != -1) // 注意 ： ES6中，为字符串提供了一个新方法，叫做 String.prototype.includes('要包含的字符串') // 如果包含，则返回 true ，否则返回 false // contain if (item.name.includes(keywords)) &#123; return item &#125; &#125;) // return newList &#125; &#125; &#125;); // 如何自定义一个私有的过滤器（局部） var vm2 = new Vue(&#123; el: '#app2', data: &#123; dt: new Date() &#125;, methods: &#123;&#125;, filters: &#123; // 定义私有过滤器 过滤器有两个 条件 【过滤器名称 和 处理函数】 // 过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了，这时候 优先调用私有过滤器 dateFormat: function (dateStr, pattern = '') &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = (dt.getMonth() + 1).toString().padStart(2, '0') var d = dt.getDate().toString().padStart(2, '0') if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours().toString().padStart(2, '0') var mm = dt.getMinutes().toString().padStart(2, '0') var ss = dt.getSeconds().toString().padStart(2, '0') return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125; ~~~~~~~` &#125; &#125; &#125;, directives: &#123; // 自定义私有指令 'fontweight': &#123; // 设置字体粗细的 bind: function (el, binding) &#123; el.style.fontWeight = binding.value &#125; &#125;, 'fontsize': function (el, binding) &#123; // 注意：这个 function 等同于 把 代码写到了 bind 和 update 中去 el.style.fontSize = parseInt(binding.value) + 'px' &#125; &#125; &#125;) // 过滤器的定义语法 // Vue.filter('过滤器的名称', function()&#123;&#125;) // 过滤器中的 function ，第一个参数，已经被规定死了，永远都是 过滤器 管道符前面 传递过来的数据 /* Vue.filter('过滤器的名称', function (data) &#123; return data + '123' &#125;) */ // document.getElementById('search').focus() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 过滤器调用时候的格式 &#123;&#123; name | 过滤器的名称 &#125;&#125; --&gt; 根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 123456789101112131415&lt;tr v-for=&quot;item in list | filterBy searchName in &apos;name&apos;&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 123&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 12345678910111213141516171819&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 123456789search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 这是基本的过滤器使用方法 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; msg | msgFormat('疯狂+1', '123') | test &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter('msgFormat', function (msg, arg, arg2) &#123; // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return msg.replace(/单纯/g, arg + arg2) &#125;) Vue.filter('test', function (msg) &#123; return msg + '========' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人' &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 私有过滤器 HTML元素： 1&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础和指令]]></title>
    <url>%2F2019%2F01%2F11%2Fvue%E5%9F%BA%E7%A1%80%E5%92%8Cvue%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[vue.js vue前言什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1. 导入Vue的包 --&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 将来 new 的Vue实例，会控制这个 元素中的所有内容 --&gt; &lt;!-- Vue 实例所控制的这个元素区域，就是我们的 V --&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 2. 创建一个Vue的实例 // 当我们导入包之后，在浏览器的内存中，就多了一个 Vue 构造函数 // 注意：我们 new 出来的这个 vm 对象，就是我们 MVVM中的 VM调度者 var vm = new Vue(&#123; el: '#app', // 表示，当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域 // 这里的 data 就是 MVVM中的 M，专门用来保存 每个页面的数据的 data: &#123; // data 属性中，存放的是 el 中要用到的数据 msg: '欢迎学习Vue' // 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码里， 里面的是相当于V，new出来的这个对象就是实例，实例里面的data就是M vue基本指令v-cloak123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 使用 v-cloak 能够解决 插值表达式闪烁的问题 --&gt; &lt;p v-cloak&gt;++++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt; &lt;/div&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123', &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-cloak实际使用的效果就是，当网速慢，加载时间长的时候，使用插值表达式不会出现 这种样子 v-text——内容绑定123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; /* display: none; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 使用 v-cloak 能够解决 插值表达式闪烁的问题 --&gt; &lt;p v-cloak&gt;++++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt; &lt;h4 v-text="msg"&gt;==================&lt;/h4&gt; &lt;!-- 默认 v-text 是没有闪烁问题的 --&gt; &lt;!-- v-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 --&gt; &lt;/div&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123', &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 默认 v-text 是没有闪烁问题的 v-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 v-html1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; /* display: none; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div v-html="msg2"&gt;1212112&lt;/div&gt; &lt;/div&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg2: '&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;', &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-html 可以将文本中的这样的显示出相应的格式。 v-bind——属性绑定123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; /* display: none; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- v-bind: 是 Vue中，提供的用于绑定属性的指令 --&gt; &lt;input type="button" value="按钮" v-bind:title="mytitle + '123'"&gt; &lt;!-- 注意： v-bind: 指令可以被简写为 :要绑定的属性 --&gt; &lt;!-- v-bind 中，可以写合法的JS表达式 --&gt; &lt;/div&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; mytitle: '这是一个自己定义的title' &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; v-on——事件绑定1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; /* display: none; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- Vue 中提供了 v-on: 事件绑定机制 --&gt; &lt;!-- &lt;input type="button" value="按钮" :title="mytitle + '123'" v-on:click="alert('hello')"&gt; --&gt; &lt;input type="button" value="按钮" @click="show"&gt; &lt;/div&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; &#125;, methods: &#123; // 这个 methods属性中定义了当前Vue实例所有可用的方法 show: function () &#123; alert('Hello') &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件修饰符 .stop 阻止冒泡（这是从里往外） .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式（这是从外往里） .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;style&gt; .inner &#123; height: 150px; background-color: darkcyan; &#125; .outer &#123; padding: 40px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 使用 .stop 阻止冒泡 --&gt; &lt;!-- &lt;div class="inner" @click="div1Handler"&gt; &lt;input type="button" value="戳他" @click.stop="btnHandler"&gt; &lt;/div&gt; --&gt; &lt;!-- 使用 .prevent 阻止默认行为 --&gt; &lt;!-- &lt;a href="http://www.baidu.com" @click.prevent="linkClick"&gt;有问题，先去百度&lt;/a&gt; --&gt; &lt;!-- 使用 .capture 实现捕获触发事件的机制 --&gt; &lt;!-- &lt;div class="inner" @click.capture="div1Handler"&gt; &lt;input type="button" value="戳他" @click="btnHandler"&gt; &lt;/div&gt; --&gt; &lt;!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 --&gt; &lt;!-- &lt;div class="inner" @click="div1Handler"&gt; &lt;input type="button" value="戳他" @click="btnHandler"&gt; &lt;/div&gt; --&gt; &lt;!-- 使用 .once 只触发一次事件处理函数 --&gt; &lt;!-- &lt;a href="http://www.baidu.com" @click.prevent.once="linkClick"&gt;有问题，先去百度&lt;/a&gt; --&gt; &lt;!-- 演示： .stop 和 .self 的区别 --&gt; &lt;!-- &lt;div class="outer" @click="div2Handler"&gt; &lt;div class="inner" @click="div1Handler"&gt; &lt;input type="button" value="戳他" @click.stop="btnHandler"&gt; &lt;/div&gt; &lt;/div&gt; --&gt; &lt;!-- .self 只会阻止自己身上冒泡行为的触发，并不会真正阻止 冒泡的行为 --&gt; &lt;!-- &lt;div class="outer" @click="div2Handler"&gt; &lt;div class="inner" @click.self="div1Handler"&gt; &lt;input type="button" value="戳他" @click="btnHandler"&gt; &lt;/div&gt; &lt;/div&gt; --&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; div1Handler() &#123; console.log('这是触发了 inner div 的点击事件') &#125;, btnHandler() &#123; console.log('这是触发了 btn 按钮 的点击事件') &#125;, linkClick() &#123; console.log('触发了连接的点击事件') &#125;, div2Handler() &#123; console.log('这是触发了 outer div 的点击事件') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-model——双向数据绑定1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt; &lt;!-- v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 --&gt; &lt;!-- &lt;input type="text" v-bind:value="msg" style="width:100%;"&gt; --&gt; &lt;!-- 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 --&gt; &lt;!-- 注意： v-model 只能运用在 表单元素中 --&gt; &lt;!-- input(radio, text, address, email....) select checkbox textarea --&gt; &lt;input type="text" style="width:100%;" v-model="msg"&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '大家都是好学生，爱敲代码，爱学习，爱思考，简直是完美，没瑕疵！' &#125;, methods: &#123; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-for——循环循环普通数组123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;p&gt;&#123;&#123;list[0]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[1]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[2]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[3]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[4]&#125;&#125;&lt;/p&gt; --&gt; &lt;p v-for="(item, i) in list"&gt;索引值：&#123;&#123;i&#125;&#125; --- 每一项：&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [1, 2, 3, 4, 5, 6] &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 循环对象数组12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p v-for="(user, i) in list"&gt;Id：&#123;&#123; user.id &#125;&#125; --- 名字：&#123;&#123; user.name &#125;&#125; --- 索引：&#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [ &#123; id: 1, name: 'zs1' &#125;, &#123; id: 2, name: 'zs2' &#125;, &#123; id: 3, name: 'zs3' &#125;, &#123; id: 4, name: 'zs4' &#125; ] &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 循环对象12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 注意：在遍历对象身上的键值对的时候， 除了 有 val key ,在第三个位置还有 一个 索引 --&gt; &lt;p v-for="(val, key, i) in user"&gt;值是： &#123;&#123; val &#125;&#125; --- 键是： &#123;&#123;key&#125;&#125; -- 索引： &#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; user: &#123; id: 1, name: '托尼·屎大颗', gender: '男' &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 迭代数字1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- in 后面我们放过 普通数组，对象数组，对象， 还可以放数字 --&gt; &lt;!-- 注意：如果使用 v-for 迭代数字的话，前面的 count 值从 1 开始 --&gt; &lt;p v-for="count in 10"&gt;这是第 &#123;&#123; count &#125;&#125; 次循环&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-for循环中key属性的使用 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div&gt; &lt;label&gt;Id: &lt;input type="text" v-model="id"&gt; &lt;/label&gt; &lt;label&gt;Name: &lt;input type="text" v-model="name"&gt; &lt;/label&gt; &lt;input type="button" value="添加" @click="add"&gt; &lt;/div&gt; &lt;!-- 注意： v-for 循环的时候，key 属性只能使用 number获取string --&gt; &lt;!-- 注意： key 在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 --&gt; &lt;!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须 在使用 v-for 的同时，指定 唯一的 字符串/数字 类型 :key 值 --&gt; &lt;p v-for="item in list" :key="item.id"&gt; &lt;input type="checkbox"&gt;&#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', list: [ &#123; id: 1, name: '李斯' &#125;, &#123; id: 2, name: '嬴政' &#125;, &#123; id: 3, name: '赵高' &#125;, &#123; id: 4, name: '韩非' &#125;, &#123; id: 5, name: '荀子' &#125; ] &#125;, methods: &#123; add() &#123; // 添加方法 this.list.unshift(&#123; id: this.id, name: this.name &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-if和v-show1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;input type="button" value="toggle" @click="toggle"&gt; --&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;!-- v-if 的特点：每次都会重新删除或创建元素 --&gt; &lt;!-- v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 --&gt; &lt;!-- v-if 有较高的切换性能消耗 --&gt; &lt;!-- v-show 有较高的初始渲染消耗 --&gt; &lt;!-- 如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show --&gt; &lt;!-- 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if --&gt; &lt;h3 v-if="flag"&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-show="flag"&gt;这是用v-show控制的元素&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123; /* toggle() &#123; this.flag = !this.flag &#125; */ &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 定时器使用——跑马灯效果例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1. 导入Vue包 --&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 2. 创建一个要控制的区域 --&gt; &lt;div id="app"&gt; &lt;input type="button" value="浪起来" @click="lang"&gt; &lt;input type="button" value="低调" @click="stop"&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;script&gt; // 注意：在 VM实例中，如果想要获取 data 上的数据，或者 想要调用 methods 中的 方法，必须通过 this.数据属性名 或 this.方法名 来进行访问，这里的this，就表示 我们 new 出来的 VM 实例对象 var vm = new Vue(&#123; el: '#app', data: &#123; msg: '猥琐发育，别浪~~！', intervalId: null // 在data上定义 定时器Id &#125;, methods: &#123; lang() &#123; // console.log(this.msg) // 获取到头的第一个字符 // this if (this.intervalId != null) return; this.intervalId = setInterval(() =&gt; &#123; var start = this.msg.substring(0, 1) // 获取到 后面的所有字符 var end = this.msg.substring(1) // 重新拼接得到新的字符串，并赋值给 this.msg this.msg = end + start &#125;, 400) // 注意： VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把 最新的数据，从data 上同步到页面中去；【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】 &#125;, stop() &#123; // 停止定时器 clearInterval(this.intervalId) // 每当清除了定时器之后，需要重新把 intervalId 置为 null this.intervalId = null; &#125; &#125; &#125;) // 分析： // 1. 给 【浪起来】 按钮，绑定一个点击事件 v-on @ // 2. 在按钮的事件处理函数中，写相关的业务逻辑代码：拿到 msg 字符串，然后 调用 字符串的 substring 来进行字符串的截取操作，把 第一个字符截取出来，放到最后一个位置即可； // 3. 为了实现点击下按钮，自动截取的功能，需要把 2 步骤中的代码，放到一个定时器中去； &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Vue中使用样式使用class样式 数组 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, isactive?&apos;active&apos;:&apos;&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, &#123;&apos;active&apos;: isactive&#125;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class=&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;style&gt; .red &#123; color: red; &#125; .thin &#123; font-weight: 200; &#125; .italic &#123; font-style: italic; &#125; .active &#123; letter-spacing: 0.5em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;h1 class="red thin"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 第一种使用方式，直接传递一个数组，注意： 这里的 class 需要使用 v-bind 做数据绑定 --&gt; &lt;!-- &lt;h1 :class="['thin', 'italic']"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在数组中使用三元表达式 --&gt; &lt;!-- &lt;h1 :class="['thin', 'italic', flag?'active':'']"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在数组中使用 对象来代替三元表达式，提高代码的可读性 --&gt; &lt;!-- &lt;h1 :class="['thin', 'italic', &#123;'active':flag&#125; ]"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在为 class 使用 v-bind 绑定 对象的时候，对象的属性是类名，由于 对象的属性可带引号，也可不带引号，所以 这里我没写引号； 属性的值 是一个标识符 --&gt; &lt;h1 :class="classObj"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: true, classObj: &#123; red: true, thin: true, italic: false, active: false &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style=&quot;&#123;color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;&#125;&quot;&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;, h1StyleObj2: &#123; fontStyle: &apos;italic&apos; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt; 示例代码： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 对象就是无序键值对的集合 --&gt; &lt;!-- &lt;h1 :style="styleObj1"&gt;这是一个h1&lt;/h1&gt; --&gt; &lt;h1 :style="[ styleObj1, styleObj2 ]"&gt;这是一个h1&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; styleObj1: &#123; color: 'red', 'font-weight': 200 &#125;, styleObj2: &#123; 'font-style': 'italic' &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
